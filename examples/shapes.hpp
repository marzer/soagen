//----------------------------------------------------------------------------------------------------------------------
// This file is a part of marzer/soagen and is subject to the the terms of the MIT license.
// Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/soagen/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.7.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// @file
/// @brief Contains the definitions of soagen::examples::boxes, soagen::examples::spheres.
///
/// @note The code and documentation in this file were generated by soagen - https://marzer.github.io/soagen

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 7
	#error soagen version mismatch - expected v0.7.X
#endif

SOAGEN_DISABLE_WARNINGS;
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// doxygen safeguards
//----------------------------------------------------------------------------------------------------------------------

#if defined(DOXYGEN) || defined(__DOXYGEN) || defined(__DOXYGEN__) || defined(__doxygen__) || defined(__POXY__)        \
	|| defined(__poxy__)

	#ifndef SOAGEN_CONSTRAINED_TEMPLATE
		#define SOAGEN_CONSTRAINED_TEMPLATE(cond, ...) template <__VA_ARGS__>
	#endif
	#ifndef SOAGEN_DOXYGEN
		#define SOAGEN_DOXYGEN 1
	#endif
	#ifndef SOAGEN_MAKE_NAME
		#define SOAGEN_MAKE_NAME(...) static_assert(true)
	#endif
	#ifndef SOAGEN_MAKE_NAMED_COLUMN
		#define SOAGEN_MAKE_NAMED_COLUMN(...) static_assert(true)
	#endif
	#ifndef SOAGEN_NODISCARD
		#define SOAGEN_NODISCARD
	#endif
	#ifndef SOAGEN_NODISCARD_CTOR
		#define SOAGEN_NODISCARD_CTOR
	#endif
	#ifndef SOAGEN_INLINE_GETTER
		#define SOAGEN_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_PURE_GETTER
		#define SOAGEN_PURE_GETTER
	#endif
	#ifndef SOAGEN_PURE_INLINE_GETTER
		#define SOAGEN_PURE_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_ALWAYS_INLINE
		#define SOAGEN_ALWAYS_INLINE inline
	#endif
	#ifndef SOAGEN_CPP20_CONSTEXPR
		#define SOAGEN_CPP20_CONSTEXPR constexpr
	#endif
	#ifndef SOAGEN_HIDDEN
		#define SOAGEN_HIDDEN(...)
	#endif
	#ifndef SOAGEN_HIDDEN_BASE
		#define SOAGEN_HIDDEN_BASE(...)
	#endif
	#ifndef SOAGEN_HIDDEN_CONSTRAINT
		#define SOAGEN_HIDDEN_CONSTRAINT(...)
	#endif
	#ifndef SOAGEN_HIDDEN_PARAM
		#define SOAGEN_HIDDEN_PARAM(...)
	#endif
	#ifndef SOAGEN_ENABLE_IF_T
		#define SOAGEN_ENABLE_IF_T(T, ...) T
	#endif
	#ifndef SOAGEN_ENABLE_IF
		#define SOAGEN_ENABLE_IF(...)
	#endif
	#ifndef SOAGEN_REQUIRES
		#define SOAGEN_REQUIRES(...)
	#endif
	#ifndef SOAGEN_EMPTY_BASES
		#define SOAGEN_EMPTY_BASES
	#endif
	#ifndef SOAGEN_COLUMN
		#define SOAGEN_COLUMN(...)
	#endif
	#if !defined(POXY_IMPLEMENTATION_DETAIL) && !(defined(__POXY__) || defined(__poxy__))
		#define POXY_IMPLEMENTATION_DETAIL(...) __VA_ARGS__
	#endif

#endif // doxygen

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

/// @cond

// clang-format off

namespace soagen::examples
{
	class boxes;
	class spheres;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_center_x
		#define SOAGEN_NAME_center_x
		SOAGEN_MAKE_NAME(center_x);
	#endif

	#ifndef SOAGEN_NAME_center_y
		#define SOAGEN_NAME_center_y
		SOAGEN_MAKE_NAME(center_y);
	#endif

	#ifndef SOAGEN_NAME_center_z
		#define SOAGEN_NAME_center_z
		SOAGEN_MAKE_NAME(center_z);
	#endif

	#ifndef SOAGEN_NAME_extents_x
		#define SOAGEN_NAME_extents_x
		SOAGEN_MAKE_NAME(extents_x);
	#endif

	#ifndef SOAGEN_NAME_extents_y
		#define SOAGEN_NAME_extents_y
		SOAGEN_MAKE_NAME(extents_y);
	#endif

	#ifndef SOAGEN_NAME_extents_z
		#define SOAGEN_NAME_extents_z
		SOAGEN_MAKE_NAME(extents_z);
	#endif

	#ifndef SOAGEN_NAME_mass
		#define SOAGEN_NAME_mass
		SOAGEN_MAKE_NAME(mass);
	#endif

	#ifndef SOAGEN_NAME_radius
		#define SOAGEN_NAME_radius
		SOAGEN_MAKE_NAME(radius);
	#endif
}

namespace soagen_struct_impl_soagen_examples_boxes
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace soagen::examples;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
					 /*  center_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /*  center_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /*  center_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* extents_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					 /* 	 mass */ soagen::column_traits<float>>;

	using soagen_allocator_type = soagen::allocator;
}
namespace soagen_struct_impl_soagen_examples_spheres
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace soagen::examples;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
					  /* center_x */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* center_y */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /* center_z */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /*   radius */ soagen::column_traits<float, soagen::max(std::size_t{ 32u }, alignof(float))>,
					  /*	 mass */ soagen::column_traits<float>>;

	using soagen_allocator_type = soagen::allocator;
}

namespace soagen::detail
{
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 0, center_x);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 1, center_y);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 2, center_z);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 3, extents_x);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 4, extents_y);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 5, extents_z);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::boxes, 6, mass);

	template <>
	struct is_soa_<soagen::examples::boxes> : std::true_type
	{};

	template <>
	struct table_traits_type_<soagen::examples::boxes>
	{
		using type = soagen_struct_impl_soagen_examples_boxes::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<soagen::examples::boxes>
	{
		using type = soagen_struct_impl_soagen_examples_boxes::soagen_allocator_type;
	};

	template <>
	struct table_type_<soagen::examples::boxes>
	{
		using type = table<table_traits_type<soagen::examples::boxes>, allocator_type<soagen::examples::boxes>>;
	};

	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::spheres, 0, center_x);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::spheres, 1, center_y);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::spheres, 2, center_z);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::spheres, 3, radius);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::spheres, 4, mass);

	template <>
	struct is_soa_<soagen::examples::spheres> : std::true_type
	{};

	template <>
	struct table_traits_type_<soagen::examples::spheres>
	{
		using type = soagen_struct_impl_soagen_examples_spheres::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<soagen::examples::spheres>
	{
		using type = soagen_struct_impl_soagen_examples_spheres::soagen_allocator_type;
	};

	template <>
	struct table_type_<soagen::examples::spheres>
	{
		using type = table<table_traits_type<soagen::examples::spheres>, allocator_type<soagen::examples::spheres>>;
	};
}

// clang-format on

/// @endcond

//----------------------------------------------------------------------------------------------------------------------
// header
//----------------------------------------------------------------------------------------------------------------------

/// @brief Types generated by soagen for example purposes.
/// @attention <b>Nothing in this namespace is required to use soagen!</b>
/// This documentation is to demonstrate what soagen is capable of generating, and is just for exposition.
namespace soagen::examples
{
}

//----------------------------------------------------------------------------------------------------------------------
// boxes
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief A SIMD-friendly AABB container.
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct boxes
	/// {
	/// 	float center_x;
	/// 	float center_y;
	/// 	float center_z;
	/// 	float extents_x;
	/// 	float extents_y;
	/// 	float extents_z;
	/// 	float mass;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES boxes //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::size_and_capacity<boxes>,
						   public soagen::mixins::resizable<boxes>,
						   public soagen::mixins::equality_comparable<boxes>,
						   public soagen::mixins::less_than_comparable<boxes>,
						   public soagen::mixins::data_ptr<boxes>,
						   public soagen::mixins::columns<boxes>,
						   public soagen::mixins::rows<boxes>,
						   public soagen::mixins::iterators<boxes>,
						   public soagen::mixins::spans<boxes>,
						   public soagen::mixins::swappable<boxes>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<boxes>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<boxes>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<boxes>;

		/// @brief The number of columns in the table.
		static constexpr size_type column_count = table_traits::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <auto Column>
		using column_traits =
			POXY_IMPLEMENTATION_DETAIL(typename table_traits::template column<static_cast<size_type>(Column)>);

		/// @brief Gets the type of a specific column in the table.
		template <auto Column>
		using column_type =
			POXY_IMPLEMENTATION_DETAIL(typename column_traits<static_cast<size_type>(Column)>::value_type);

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<boxes>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::rvalue_iterator_type<boxes>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::const_iterator_type<boxes>;

		/// @brief Regular (lvalue-qualified) span type.
		using span_type = soagen::span_type<boxes>;

		/// @brief Rvalue-qualified span type.
		using rvalue_span_type = soagen::rvalue_span_type<boxes>;

		/// @brief Const-qualified span type.
		using const_span_type = soagen::const_span_type<boxes>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<boxes>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::rvalue_row_type<boxes>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::const_row_type<boxes>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using columns = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		enum class columns : size_type
		{
			center_x  = 0,
			center_y  = 1,
			center_z  = 2,
			extents_x = 3,
			extents_y = 4,
			extents_z = 5,
			mass	  = 6,
		};
#endif

		/// @brief Gets the name of the specified column as a null-terminated string.
		template <auto Column>
		static constexpr auto& column_name = soagen::detail::column_name<boxes, static_cast<size_type>(Column)>::value;

		static constexpr float default_mass = 2.0;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		boxes() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(boxes&&) = default;

		/// @brief Move-assignment operator.
		boxes& operator=(boxes&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(const boxes&) = default;

		/// @brief Copy-assignment operator.
		boxes& operator=(const boxes&) = default;

		/// @brief Destructor.
		~boxes() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) erase(size_type pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																   //
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				   //
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos)   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)			 //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)							 //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Swaps two columns.
		///
		/// @availability The two columns must have the same underlying value_type.
		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Removes the last row(s) from the table.
		boxes& pop_back(size_type num = 1) noexcept(...);

		/// @brief Removes all rows from table.
		boxes& clear() noexcept;

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		boxes& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(boxes& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		// ------ push_back() --------------------------------------------------------------------------

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::param_type center_x,
						 column_traits<1>::param_type center_y,
						 column_traits<2>::param_type center_z,
						 column_traits<3>::param_type extents_x = 0.5,
						 column_traits<4>::param_type extents_y = 0.5,
						 column_traits<5>::param_type extents_z = 0.5,
						 column_traits<6>::param_type mass		= default_mass) //
			noexcept(table_traits::push_back_is_nothrow<table_type>)	   //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(center_x),
								static_cast<column_traits<1>::param_forward_type>(center_y),
								static_cast<column_traits<2>::param_forward_type>(center_z),
								static_cast<column_traits<3>::param_forward_type>(extents_x),
								static_cast<column_traits<4>::param_forward_type>(extents_y),
								static_cast<column_traits<5>::param_forward_type>(extents_z),
								static_cast<column_traits<6>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::rvalue_type center_x,
						 column_traits<1>::rvalue_type center_y,
						 column_traits<2>::rvalue_type center_z,
						 column_traits<3>::rvalue_type extents_x = 0.5,
						 column_traits<4>::rvalue_type extents_y = 0.5,
						 column_traits<5>::rvalue_type extents_z = 0.5,
						 column_traits<6>::rvalue_type mass		 = default_mass) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(center_x),
								static_cast<column_traits<1>::rvalue_forward_type>(center_y),
								static_cast<column_traits<2>::rvalue_forward_type>(center_z),
								static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
								static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
								static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
								static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at the end of the table.
		SOAGEN_CONSTRAINED_TEMPLATE((table_traits::row_constructible_from<CenterX&&,
																		  CenterY&&,
																		  CenterZ&&,
																		  ExtentsX&&,
																		  ExtentsY&&,
																		  ExtentsZ&&,
																		  Mass&&>), //
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX = column_traits<3>::default_emplace_type,
									typename ExtentsY = column_traits<4>::default_emplace_type,
									typename ExtentsZ = column_traits<5>::default_emplace_type,
									typename Mass	  = column_traits<6>::default_emplace_type) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(CenterX&& center_x,
							CenterY&& center_y,
							CenterZ&& center_z,
							ExtentsX&& extents_x = 0.5,
							ExtentsY&& extents_y = 0.5,
							ExtentsZ&& extents_z = 0.5,
							Mass&& mass			 = default_mass) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   ExtentsX&&,
														   ExtentsY&&,
														   ExtentsZ&&,
														   Mass&&>) //
		{
			table_.emplace_back(static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<ExtentsX&&>(extents_x),
								static_cast<ExtentsY&&>(extents_y),
								static_cast<ExtentsZ&&>(extents_z),
								static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table by unpacking a tuple-like object.
		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(Tuple&& tuple_)										 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move/copy-constructible and move/copy-assignable.
		/// @{

	  private:
		/// @cond

		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

		/// @endcond

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) insert(size_type index_,
												  column_traits<0>::param_type center_x,
												  column_traits<1>::param_type center_y,
												  column_traits<2>::param_type center_z,
												  column_traits<3>::param_type extents_x = 0.5,
												  column_traits<4>::param_type extents_y = 0.5,
												  column_traits<5>::param_type extents_z = 0.5,
												  column_traits<6>::param_type mass		 = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									//
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
					  column_traits<0>::rvalue_type center_x,
					  column_traits<1>::rvalue_type center_y,
					  column_traits<2>::rvalue_type center_z,
					  column_traits<3>::rvalue_type extents_x = 0.5,
					  column_traits<4>::rvalue_type extents_y = 0.5,
					  column_traits<5>::rvalue_type extents_z = 0.5,
					  column_traits<6>::rvalue_type mass	  = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)		 //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type extents_x = 0.5,
													column_traits<4>::param_type extents_y = 0.5,
													column_traits<5>::param_type extents_z = 0.5,
													column_traits<6>::param_type mass	   = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									  //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type center_x,
														  column_traits<1>::param_type center_y,
														  column_traits<2>::param_type center_z,
														  column_traits<3>::param_type extents_x = 0.5,
														  column_traits<4>::param_type extents_y = 0.5,
														  column_traits<5>::param_type extents_z = 0.5,
														  column_traits<6>::param_type mass		 = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)											//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type extents_x = 0.5,
						column_traits<4>::rvalue_type extents_y = 0.5,
						column_traits<5>::rvalue_type extents_z = 0.5,
						column_traits<6>::rvalue_type mass		= default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type center_x,
							  column_traits<1>::rvalue_type center_y,
							  column_traits<2>::rvalue_type center_z,
							  column_traits<3>::rvalue_type extents_x = 0.5,
							  column_traits<4>::rvalue_type extents_y = 0.5,
							  column_traits<5>::rvalue_type extents_z = 0.5,
							  column_traits<6>::rvalue_type mass	  = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)				 //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX = column_traits<3>::default_emplace_type,
									typename ExtentsY = column_traits<4>::default_emplace_type,
									typename ExtentsZ = column_traits<5>::default_emplace_type,
									typename Mass	  = column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<CenterX&&,
																						   CenterY&&,
																						   CenterZ&&,
																						   ExtentsX&&,
																						   ExtentsY&&,
																						   ExtentsZ&&,
																						   Mass&&>
												   && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) emplace(size_type index_,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   ExtentsX&& extents_x = 0.5,
												   ExtentsY&& extents_y = 0.5,
												   ExtentsZ&& extents_z = 0.5,
												   Mass&& mass			= default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>) //
		{
			table_.emplace(index_,
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			 //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX = column_traits<3>::default_emplace_type,
									typename ExtentsY = column_traits<4>::default_emplace_type,
									typename ExtentsZ = column_traits<5>::default_emplace_type,
									typename Mass	  = column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<CenterX&&,
																						   CenterY&&,
																						   CenterZ&&,
																						   ExtentsX&&,
																						   ExtentsY&&,
																						   ExtentsZ&&,
																						   Mass&&>
												   && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) emplace(iterator iter_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 ExtentsX&& extents_x = 0.5,
													 ExtentsY&& extents_y = 0.5,
													 ExtentsZ&& extents_z = 0.5,
													 Mass&& mass		  = default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			 //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename CenterX,
									typename CenterY,
									typename CenterZ,
									typename ExtentsX = column_traits<3>::default_emplace_type,
									typename ExtentsY = column_traits<4>::default_emplace_type,
									typename ExtentsZ = column_traits<5>::default_emplace_type,
									typename Mass	  = column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<CenterX&&,
																						   CenterY&&,
																						   CenterZ&&,
																						   ExtentsX&&,
																						   ExtentsY&&,
																						   ExtentsZ&&,
																						   Mass&&>
												   && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) emplace(const_iterator iter_,
														   CenterX&& center_x,
														   CenterY&& center_y,
														   CenterZ&& center_z,
														   ExtentsX&& extents_x = 0.5,
														   ExtentsY&& extents_y = 0.5,
														   ExtentsZ&& extents_z = 0.5,
														   Mass&& mass			= default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)						 //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @}

		/// @name Columns
		/// @{

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(boxes, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<boxes, Column>>(table_.template column<Column>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(boxes, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<boxes, Column>>(table_.template column<Column>());
		}

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() noexcept;

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		constexpr float* center_x() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		constexpr const float* center_x() const noexcept;

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		constexpr float* center_y() noexcept;

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		constexpr const float* center_y() const noexcept;

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		constexpr float* center_z() noexcept;

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		constexpr const float* center_z() const noexcept;

		/// @brief Returns a pointer to the elements in column [3]: extents_x.
		constexpr float* extents_x() noexcept;

		/// @brief Returns a pointer to the elements in column [3]: extents_x.
		constexpr const float* extents_x() const noexcept;

		/// @brief Returns a pointer to the elements in column [4]: extents_y.
		constexpr float* extents_y() noexcept;

		/// @brief Returns a pointer to the elements in column [4]: extents_y.
		constexpr const float* extents_y() const noexcept;

		/// @brief Returns a pointer to the elements in column [5]: extents_z.
		constexpr float* extents_z() noexcept;

		/// @brief Returns a pointer to the elements in column [5]: extents_z.
		constexpr const float* extents_z() const noexcept;

		/// @brief Returns a pointer to the elements in column [6]: mass.
		constexpr float* mass() noexcept;

		/// @brief Returns a pointer to the elements in column [6]: mass.
		constexpr const float* mass() const noexcept;

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) noexcept(...);

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const noexcept(...);

#endif

		/// @}

#if SOAGEN_DOXYGEN

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept;

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept;

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept;

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		///
		/// @warning This value is `capacity() * (sizeof() for every column) + (alignment padding)`.
		/// It is **not** based on `size()`! If you are using the value returned by this function
		/// in conjunction with `data()` to do serialization, hashing, etc, use `shrink_to_fit()` first.
		constexpr size_type allocation_size() const noexcept;

		/// @brief Reserves storage for (at least) the given number of rows.
		boxes& reserve(size_type new_cap) noexcept(...)

			/// @brief Returns the number of rows that can be held in currently allocated storage.
			constexpr size_type capacity() const noexcept;

		/// @brief Frees unused capacity.
		boxes& shrink_to_fit() noexcept(...);

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<boxes, Cols...> begin() & noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<boxes, Cols...> end() & noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<boxes&&, Cols...> begin() && noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<boxes&&, Cols...> end() && noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<boxes, Cols...> begin() const& noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<boxes, Cols...> end() const& noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<boxes, Cols...> cbegin() const noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<boxes, Cols...> cend() const noexcept;

		/// @}

		/// @name Rows
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::row_type<boxes, Cols...> row(size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		row_type operator[](size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::row_type<boxes, Cols...> at(size_type index) &;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::row_type<boxes, Cols...> front() & noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::row_type<boxes, Cols...> back() & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::row_type<boxes&&, Cols...> row(size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		rvalue_row_type operator[](size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::row_type<boxes&&, Cols...> at(size_type index) &&;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::row_type<boxes&&, Cols...> front() && noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::row_type<boxes&&, Cols...> back() && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::const_row_type<boxes, Cols...> row(size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		const_row_type operator[](size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::const_row_type<boxes, Cols...> at(size_type index) const&;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::const_row_type<boxes, Cols...> front() const& noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::const_row_type<boxes, Cols...> back() const& noexcept;

		/// @}

		/// @name Spans
		/// @{

		/// @brief Returns a span of (some part of) the table.
		span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) & noexcept;

		/// @brief Returns an rvalue-qualified span of (some part of) the table.
		rvalue_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) && noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) const& noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type const_subspan(size_type start, size_type count = static_cast<size_type>(-1)) const noexcept;

		/// @}

#endif
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::boxes.
	///
	/// @availability	This overload is only available when #soagen::examples::boxes::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<boxes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(boxes& lhs, boxes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<boxes>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief A SIMD-friendly bounding sphere container.
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct spheres
	/// {
	/// 	float center_x;
	/// 	float center_y;
	/// 	float center_z;
	/// 	float radius;
	/// 	float mass;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES spheres //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::size_and_capacity<spheres>,
						   public soagen::mixins::resizable<spheres>,
						   public soagen::mixins::equality_comparable<spheres>,
						   public soagen::mixins::less_than_comparable<spheres>,
						   public soagen::mixins::data_ptr<spheres>,
						   public soagen::mixins::columns<spheres>,
						   public soagen::mixins::rows<spheres>,
						   public soagen::mixins::iterators<spheres>,
						   public soagen::mixins::spans<spheres>,
						   public soagen::mixins::swappable<spheres>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<spheres>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<spheres>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<spheres>;

		/// @brief The number of columns in the table.
		static constexpr size_type column_count = table_traits::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <auto Column>
		using column_traits =
			POXY_IMPLEMENTATION_DETAIL(typename table_traits::template column<static_cast<size_type>(Column)>);

		/// @brief Gets the type of a specific column in the table.
		template <auto Column>
		using column_type =
			POXY_IMPLEMENTATION_DETAIL(typename column_traits<static_cast<size_type>(Column)>::value_type);

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<spheres>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::rvalue_iterator_type<spheres>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::const_iterator_type<spheres>;

		/// @brief Regular (lvalue-qualified) span type.
		using span_type = soagen::span_type<spheres>;

		/// @brief Rvalue-qualified span type.
		using rvalue_span_type = soagen::rvalue_span_type<spheres>;

		/// @brief Const-qualified span type.
		using const_span_type = soagen::const_span_type<spheres>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<spheres>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::rvalue_row_type<spheres>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::const_row_type<spheres>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using columns = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		enum class columns : size_type
		{
			center_x = 0,
			center_y = 1,
			center_z = 2,
			radius	 = 3,
			mass	 = 4,
		};
#endif

		/// @brief Gets the name of the specified column as a null-terminated string.
		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<spheres, static_cast<size_type>(Column)>::value;

		static constexpr float default_mass = 1.0;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		/// @brief Move-assignment operator.
		spheres& operator=(spheres&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		/// @brief Copy-assignment operator.
		spheres& operator=(const spheres&) = default;

		/// @brief Destructor.
		~spheres() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) erase(size_type pos)  //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																   //
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				   //
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos)   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)			 //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)							 //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Swaps two columns.
		///
		/// @availability The two columns must have the same underlying value_type.
		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Removes the last row(s) from the table.
		spheres& pop_back(size_type num = 1) noexcept(...);

		/// @brief Removes all rows from table.
		spheres& clear() noexcept;

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		spheres& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(spheres& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		// ------ push_back() --------------------------------------------------------------------------

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::param_type center_x,
						   column_traits<1>::param_type center_y,
						   column_traits<2>::param_type center_z,
						   column_traits<3>::param_type radius = 0.5,
						   column_traits<4>::param_type mass   = default_mass) //
			noexcept(table_traits::push_back_is_nothrow<table_type>)		 //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(center_x),
								static_cast<column_traits<1>::param_forward_type>(center_y),
								static_cast<column_traits<2>::param_forward_type>(center_z),
								static_cast<column_traits<3>::param_forward_type>(radius),
								static_cast<column_traits<4>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::rvalue_type center_x,
						   column_traits<1>::rvalue_type center_y,
						   column_traits<2>::rvalue_type center_z,
						   column_traits<3>::rvalue_type radius = 0.5,
						   column_traits<4>::rvalue_type mass	= default_mass) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>)	  //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(center_x),
								static_cast<column_traits<1>::rvalue_forward_type>(center_y),
								static_cast<column_traits<2>::rvalue_forward_type>(center_z),
								static_cast<column_traits<3>::rvalue_forward_type>(radius),
								static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at the end of the table.
		SOAGEN_CONSTRAINED_TEMPLATE(
			(table_traits::row_constructible_from<CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>), //
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius = column_traits<3>::default_emplace_type,
			typename Mass	= column_traits<4>::default_emplace_type) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(CenterX&& center_x,
							  CenterY&& center_y,
							  CenterZ&& center_z,
							  Radius&& radius = 0.5,
							  Mass&& mass	  = default_mass) //
			noexcept(
				table_traits::emplace_back_is_nothrow<table_type, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>) //
		{
			table_.emplace_back(static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<Radius&&>(radius),
								static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table by unpacking a tuple-like object.
		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(Tuple&& tuple_)									 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move/copy-constructible and move/copy-assignable.
		/// @{

	  private:
		/// @cond

		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

		/// @endcond

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) insert(size_type index_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type radius = 0.5,
													column_traits<4>::param_type mass	= default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									  //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type radius = 0.5,
						column_traits<4>::rvalue_type mass	 = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)		   //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type radius = 0.5,
													column_traits<4>::param_type mass	= default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									  //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type center_x,
														  column_traits<1>::param_type center_y,
														  column_traits<2>::param_type center_z,
														  column_traits<3>::param_type radius = 0.5,
														  column_traits<4>::param_type mass	  = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)											//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type radius = 0.5,
						column_traits<4>::rvalue_type mass	 = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type center_x,
							  column_traits<1>::rvalue_type center_y,
							  column_traits<2>::rvalue_type center_z,
							  column_traits<3>::rvalue_type radius = 0.5,
							  column_traits<4>::rvalue_type mass   = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type>)				 //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius = column_traits<3>::default_emplace_type,
			typename Mass	= column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
				  bool sfinae = table_traits::row_constructible_from<CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>
							 && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) emplace(size_type index_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 Radius&& radius = 0.5,
													 Mass&& mass	 = default_mass)									  //
			noexcept(table_traits::emplace_is_nothrow<table_type, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>) //
		{
			table_.emplace(index_,
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			   //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius = column_traits<3>::default_emplace_type,
			typename Mass	= column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
				  bool sfinae = table_traits::row_constructible_from<CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>
							 && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) emplace(iterator iter_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 Radius&& radius = 0.5,
													 Mass&& mass	 = default_mass)									  //
			noexcept(table_traits::emplace_is_nothrow<table_type, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			 //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename CenterX,
			typename CenterY,
			typename CenterZ,
			typename Radius = column_traits<3>::default_emplace_type,
			typename Mass	= column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
				  bool sfinae = table_traits::row_constructible_from<CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>
							 && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) emplace(const_iterator iter_,
														   CenterX&& center_x,
														   CenterY&& center_y,
														   CenterZ&& center_z,
														   Radius&& radius = 0.5,
														   Mass&& mass	   = default_mass)								  //
			noexcept(table_traits::emplace_is_nothrow<table_type, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move/copy-constructible and move/copy-assignable.
		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple SOAGEN_HIDDEN_PARAM(
										bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_)) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)						 //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @}

		/// @name Columns
		/// @{

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(spheres, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<spheres, Column>>(table_.template column<Column>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(spheres, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<spheres, Column>>(table_.template column<Column>());
		}

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() noexcept;

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		constexpr float* center_x() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		constexpr const float* center_x() const noexcept;

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		constexpr float* center_y() noexcept;

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		constexpr const float* center_y() const noexcept;

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		constexpr float* center_z() noexcept;

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		constexpr const float* center_z() const noexcept;

		/// @brief Returns a pointer to the elements in column [3]: radius.
		constexpr float* radius() noexcept;

		/// @brief Returns a pointer to the elements in column [3]: radius.
		constexpr const float* radius() const noexcept;

		/// @brief Returns a pointer to the elements in column [4]: mass.
		constexpr float* mass() noexcept;

		/// @brief Returns a pointer to the elements in column [4]: mass.
		constexpr const float* mass() const noexcept;

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) noexcept(...);

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const noexcept(...);

#endif

		/// @}

#if SOAGEN_DOXYGEN

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept;

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept;

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept;

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		///
		/// @warning This value is `capacity() * (sizeof() for every column) + (alignment padding)`.
		/// It is **not** based on `size()`! If you are using the value returned by this function
		/// in conjunction with `data()` to do serialization, hashing, etc, use `shrink_to_fit()` first.
		constexpr size_type allocation_size() const noexcept;

		/// @brief Reserves storage for (at least) the given number of rows.
		spheres& reserve(size_type new_cap) noexcept(...)

			/// @brief Returns the number of rows that can be held in currently allocated storage.
			constexpr size_type capacity() const noexcept;

		/// @brief Frees unused capacity.
		spheres& shrink_to_fit() noexcept(...);

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<spheres, Cols...> begin() & noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<spheres, Cols...> end() & noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<spheres&&, Cols...> begin() && noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::iterator_type<spheres&&, Cols...> end() && noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<spheres, Cols...> begin() const& noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<spheres, Cols...> end() const& noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<spheres, Cols...> cbegin() const noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Cols>
		constexpr soagen::const_iterator_type<spheres, Cols...> cend() const noexcept;

		/// @}

		/// @name Rows
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::row_type<spheres, Cols...> row(size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		row_type operator[](size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::row_type<spheres, Cols...> at(size_type index) &;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::row_type<spheres, Cols...> front() & noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::row_type<spheres, Cols...> back() & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::row_type<spheres&&, Cols...> row(size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		rvalue_row_type operator[](size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::row_type<spheres&&, Cols...> at(size_type index) &&;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::row_type<spheres&&, Cols...> front() && noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::row_type<spheres&&, Cols...> back() && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Cols Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Cols>
		soagen::const_row_type<spheres, Cols...> row(size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		const_row_type operator[](size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		template <auto... Cols>
		soagen::const_row_type<spheres, Cols...> at(size_type index) const&;

		/// @brief Returns the very first row in the table.
		template <auto... Cols>
		soagen::const_row_type<spheres, Cols...> front() const& noexcept;

		/// @brief Returns the very last row in the table.
		template <auto... Cols>
		soagen::const_row_type<spheres, Cols...> back() const& noexcept;

		/// @}

		/// @name Spans
		/// @{

		/// @brief Returns a span of (some part of) the table.
		span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) & noexcept;

		/// @brief Returns an rvalue-qualified span of (some part of) the table.
		rvalue_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) && noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) const& noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type const_subspan(size_type start, size_type count = static_cast<size_type>(-1)) const noexcept;

		/// @}

#endif
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::spheres.
	///
	/// @availability	This overload is only available when #soagen::examples::spheres::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
