//----------------------------------------------------------------------------------------------------------------------
// This file is a part of marzer/soagen and is subject to the the terms of the MIT license.
// Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/soagen/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.2.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// @file
/// @brief Contains the definitions of soagen::examples::boxes, soagen::examples::spheres.
///
/// @note The code and documentation in this file were generated by soagen - https://marzer.github.io/soagen

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 2
	#error soagen version mismatch - expected v0.2.X
#endif

SOAGEN_DISABLE_WARNINGS;
#if SOAGEN_HAS_EXCEPTIONS
	#include <stdexcept>
#endif
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_CLANG >= 16
	#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// doxygen safeguards
//----------------------------------------------------------------------------------------------------------------------

#if defined(DOXYGEN) || defined(__DOXYGEN) || defined(__DOXYGEN__) || defined(__doxygen__) || defined(__POXY__)        \
	|| defined(__poxy__)

	#ifndef SOAGEN_DOXYGEN
		#define SOAGEN_DOXYGEN 1
	#endif
	#ifndef SOAGEN_MAKE_NAME
		#define SOAGEN_MAKE_NAME(...) static_assert(true)
	#endif
	#ifndef SOAGEN_MAKE_COLUMN
		#define SOAGEN_MAKE_COLUMN(...) static_assert(true)
	#endif
	#ifndef SOAGEN_NODISCARD
		#define SOAGEN_NODISCARD
	#endif
	#ifndef SOAGEN_NODISCARD_CTOR
		#define SOAGEN_NODISCARD_CTOR
	#endif
	#ifndef SOAGEN_INLINE_GETTER
		#define SOAGEN_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_PURE_GETTER
		#define SOAGEN_PURE_GETTER
	#endif
	#ifndef SOAGEN_PURE_INLINE_GETTER
		#define SOAGEN_PURE_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_ALWAYS_INLINE
		#define SOAGEN_ALWAYS_INLINE inline
	#endif
	#ifndef SOAGEN_CPP20_CONSTEXPR
		#define SOAGEN_CPP20_CONSTEXPR constexpr
	#endif
	#ifndef SOAGEN_HIDDEN
		#define SOAGEN_HIDDEN(...)
	#endif
	#ifndef SOAGEN_HIDDEN_BASE
		#define SOAGEN_HIDDEN_BASE(...)
	#endif
	#ifndef SOAGEN_HIDDEN_CONSTRAINT
		#define SOAGEN_HIDDEN_CONSTRAINT(...)
	#endif
	#ifndef SOAGEN_HIDDEN_PARAM
		#define SOAGEN_HIDDEN_PARAM(...)
	#endif
	#ifndef SOAGEN_ENABLE_IF_T
		#define SOAGEN_ENABLE_IF_T(T, ...) T
	#endif
	#ifndef SOAGEN_ENABLE_IF
		#define SOAGEN_ENABLE_IF(...)
	#endif
	#ifndef SOAGEN_REQUIRES
		#define SOAGEN_REQUIRES(...)
	#endif
	#ifndef SOAGEN_EMPTY_BASES
		#define SOAGEN_EMPTY_BASES
	#endif
	#ifndef SOAGEN_COLUMN
		#define SOAGEN_COLUMN(...)
	#endif
	#ifndef SOAGEN_ALIGNED_COLUMN
		#define SOAGEN_ALIGNED_COLUMN(...)
	#endif
	#if !defined(POXY_IMPLEMENTATION_DETAIL) && !(defined(__POXY__) || defined(__poxy__))
		#define POXY_IMPLEMENTATION_DETAIL(...) __VA_ARGS__
	#endif

#endif // doxygen

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

/// @cond

// clang-format off

namespace soagen::examples
{
	class boxes;
	class spheres;
}

namespace soagen
{
	template <>
	inline constexpr bool is_soa<soagen::examples::boxes> = true;

	template <>
	inline constexpr bool is_soa<soagen::examples::spheres> = true;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_center_x
		#define SOAGEN_NAME_center_x
		SOAGEN_MAKE_NAME(center_x);
	#endif

	#ifndef SOAGEN_NAME_center_y
		#define SOAGEN_NAME_center_y
		SOAGEN_MAKE_NAME(center_y);
	#endif

	#ifndef SOAGEN_NAME_center_z
		#define SOAGEN_NAME_center_z
		SOAGEN_MAKE_NAME(center_z);
	#endif

	#ifndef SOAGEN_NAME_extents_x
		#define SOAGEN_NAME_extents_x
		SOAGEN_MAKE_NAME(extents_x);
	#endif

	#ifndef SOAGEN_NAME_extents_y
		#define SOAGEN_NAME_extents_y
		SOAGEN_MAKE_NAME(extents_y);
	#endif

	#ifndef SOAGEN_NAME_extents_z
		#define SOAGEN_NAME_extents_z
		SOAGEN_MAKE_NAME(extents_z);
	#endif

	#ifndef SOAGEN_NAME_mass
		#define SOAGEN_NAME_mass
		SOAGEN_MAKE_NAME(mass);
	#endif

	#ifndef SOAGEN_NAME_radius
		#define SOAGEN_NAME_radius
		SOAGEN_MAKE_NAME(radius);
	#endif

	template <>
	struct table_traits_type_<soagen::examples::boxes>
	{
		using type = table_traits<
		/*	center_x */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/*	center_y */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/*	center_z */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/* extents_x */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/* extents_y */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/* extents_z */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/*		mass */ column_traits<float>>;
	};

	template <>
	struct allocator_type_<soagen::examples::boxes>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 0, center_x);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 1, center_y);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 2, center_z);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 3, extents_x);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 4, extents_y);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 5, extents_z);
	SOAGEN_MAKE_COLUMN(soagen::examples::boxes, 6, mass);

	template <>
	struct table_type_<soagen::examples::boxes>
	{
		using type = table<table_traits_type<soagen::examples::boxes>, soagen::allocator>;
	};

	template <>
	struct table_traits_type_<soagen::examples::spheres>
	{
		using type = table_traits<
		/* center_x */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/* center_y */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/* center_z */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/*	 radius */ column_traits<float, soagen::max(size_t{ 32 }, alignof(float))>,
		/*	   mass */ column_traits<float>>;
	};

	template <>
	struct allocator_type_<soagen::examples::spheres>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COLUMN(soagen::examples::spheres, 0, center_x);
	SOAGEN_MAKE_COLUMN(soagen::examples::spheres, 1, center_y);
	SOAGEN_MAKE_COLUMN(soagen::examples::spheres, 2, center_z);
	SOAGEN_MAKE_COLUMN(soagen::examples::spheres, 3, radius);
	SOAGEN_MAKE_COLUMN(soagen::examples::spheres, 4, mass);

	template <>
	struct table_type_<soagen::examples::spheres>
	{
		using type = table<table_traits_type<soagen::examples::spheres>, soagen::allocator>;
	};
}

// clang-format on

/// @endcond

//----------------------------------------------------------------------------------------------------------------------
// header
//----------------------------------------------------------------------------------------------------------------------

/// @brief Types generated by soagen for example purposes.
/// @attention <b>Nothing in this namespace is required to use soagen!</b>
/// This documentation is to demonstrate what soagen is capable of generating, and is just for exposition.
namespace soagen::examples
{
}

//----------------------------------------------------------------------------------------------------------------------
// boxes
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief A SIMD-friendly AABB container.
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct boxes
	/// {
	/// 	float center_x;
	/// 	float center_y;
	/// 	float center_z;
	/// 	float extents_x;
	/// 	float extents_y;
	/// 	float extents_z;
	/// 	float mass;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES boxes //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::resizable<boxes>,
						   public soagen::mixins::equality_comparable<boxes>,
						   public soagen::mixins::less_than_comparable<boxes>,
						   public soagen::mixins::data_ptr<boxes>,
						   public soagen::mixins::const_data_ptr<boxes>,
						   public soagen::mixins::swappable<boxes>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<boxes>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<boxes>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<boxes>;

		/// @brief The number of columns in the table.
		static constexpr size_type column_count = soagen::table_traits_type<boxes>::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		/// @brief Gets the type of a specific column in the table.
		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<boxes&>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::iterator_type<const boxes&>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::iterator_type<boxes&&>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<boxes&>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::row_type<const boxes&>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::row_type<boxes&&>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using columns = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		enum class columns : size_type
		{
			center_x  = 0,
			center_y  = 1,
			center_z  = 2,
			extents_x = 3,
			extents_y = 4,
			extents_z = 5,
			mass	  = 6,
		};
#endif

		/// @brief Gets the name of the specified column as a null-terminated string.
		template <auto Column>
		static constexpr auto& column_name = soagen::detail::column_name<boxes, static_cast<size_type>(Column)>::value;

		static constexpr float default_mass = 2.0;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		boxes() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(boxes&&) = default;

		/// @brief Move-assignment operator.
		boxes& operator=(boxes&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		boxes(const boxes&) = default;

		/// @brief Copy-assignment operator.
		boxes& operator=(const boxes&) = default;

		/// @brief Destructor.
		~boxes() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit boxes(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table access
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		///
		/// @warning This value is `capacity() * (sizeof() for every column) + (alignment padding)`.
		/// It is **not** based on `size()`! If you are using the value returned by this function
		/// in conjunction with `data()` to do serialization, hashing, etc, use `shrink_to_fit()` first.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Swaps two columns.
		///
		/// @availability The two columns must have the same underlying value_type.
		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		boxes& swap_columns() //
			noexcept(noexcept(
				std::declval<table_type&>().template swap_columns<static_cast<size_t>(A), static_cast<size_t>(B)>()))
		{
			table_.template swap_columns<static_cast<size_t>(A), static_cast<size_t>(B)>();
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		boxes& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type, size_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(boxes& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(column_traits<0>::param_type center_x,
						 column_traits<1>::param_type center_y,
						 column_traits<2>::param_type center_z,
						 column_traits<3>::param_type extents_x = 0.5,
						 column_traits<4>::param_type extents_y = 0.5,
						 column_traits<5>::param_type extents_z = 0.5,
						 column_traits<6>::param_type mass		= default_mass) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(center_x),
								static_cast<column_traits<1>::param_forward_type>(center_y),
								static_cast<column_traits<2>::param_forward_type>(center_z),
								static_cast<column_traits<3>::param_forward_type>(extents_x),
								static_cast<column_traits<4>::param_forward_type>(extents_y),
								static_cast<column_traits<5>::param_forward_type>(extents_z),
								static_cast<column_traits<6>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN(template <bool sfinae = table_traits::rvalue_type_list_is_distinct>)
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(SOAGEN_ENABLE_IF_T(column_traits<0>::rvalue_type, sfinae) center_x,
						 column_traits<1>::rvalue_type center_y,
						 column_traits<2>::rvalue_type center_z,
						 column_traits<3>::rvalue_type extents_x = 0.5,
						 column_traits<4>::rvalue_type extents_y = 0.5,
						 column_traits<5>::rvalue_type extents_z = 0.5,
						 column_traits<6>::rvalue_type mass		 = default_mass) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(center_x),
								static_cast<column_traits<1>::rvalue_forward_type>(center_y),
								static_cast<column_traits<2>::rvalue_forward_type>(center_z),
								static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
								static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
								static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
								static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table.
		template <typename Table, auto... Columns SOAGEN_ENABLE_IF(soagen::is_soa<soagen::remove_cvref<Table>>)>
		SOAGEN_CPP20_CONSTEXPR
		boxes& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX = column_traits<3>::default_emplace_type,
				  typename ExtentsY = column_traits<4>::default_emplace_type,
				  typename ExtentsZ = column_traits<5>::default_emplace_type,
				  typename Mass		= column_traits<6>::default_emplace_type>
		SOAGEN_CPP20_CONSTEXPR
		boxes& emplace_back(CenterX&& center_x,
							CenterY&& center_y,
							CenterZ&& center_z,
							ExtentsX&& extents_x = 0.5,
							ExtentsY&& extents_y = 0.5,
							ExtentsZ&& extents_z = 0.5,
							Mass&& mass			 = default_mass) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&,
														   CenterX&&,
														   CenterY&&,
														   CenterZ&&,
														   ExtentsX&&,
														   ExtentsY&&,
														   ExtentsZ&&,
														   Mass&&>)
		{
			table_.emplace_back(static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<ExtentsX&&>(extents_x),
								static_cast<ExtentsY&&>(extents_y),
								static_cast<ExtentsZ&&>(extents_z),
								static_cast<Mass&&>(mass));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move-constructible and move-assignable.
		/// @{

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) insert(size_type index_,
												  column_traits<0>::param_type center_x,
												  column_traits<1>::param_type center_y,
												  column_traits<2>::param_type center_z,
												  column_traits<3>::param_type extents_x = 0.5,
												  column_traits<4>::param_type extents_y = 0.5,
												  column_traits<5>::param_type extents_z = 0.5,
												  column_traits<6>::param_type mass		 = default_mass)		  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type extents_x = 0.5,
													column_traits<4>::param_type extents_y = 0.5,
													column_traits<5>::param_type extents_z = 0.5,
													column_traits<6>::param_type mass	   = default_mass)	  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type center_x,
														  column_traits<1>::param_type center_y,
														  column_traits<2>::param_type center_z,
														  column_traits<3>::param_type extents_x = 0.5,
														  column_traits<4>::param_type extents_y = 0.5,
														  column_traits<5>::param_type extents_z = 0.5,
														  column_traits<6>::param_type mass		 = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)	//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(extents_x),
						   static_cast<column_traits<4>::param_forward_type>(extents_y),
						   static_cast<column_traits<5>::param_forward_type>(extents_z),
						   static_cast<column_traits<6>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
					  column_traits<0>::rvalue_type center_x,
					  column_traits<1>::rvalue_type center_y,
					  column_traits<2>::rvalue_type center_z,
					  column_traits<3>::rvalue_type extents_x = 0.5,
					  column_traits<4>::rvalue_type extents_y = 0.5,
					  column_traits<5>::rvalue_type extents_z = 0.5,
					  column_traits<6>::rvalue_type mass	  = default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type extents_x = 0.5,
						column_traits<4>::rvalue_type extents_y = 0.5,
						column_traits<5>::rvalue_type extents_z = 0.5,
						column_traits<6>::rvalue_type mass		= default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type center_x,
							  column_traits<1>::rvalue_type center_y,
							  column_traits<2>::rvalue_type center_z,
							  column_traits<3>::rvalue_type extents_x = 0.5,
							  column_traits<4>::rvalue_type extents_y = 0.5,
							  column_traits<5>::rvalue_type extents_z = 0.5,
							  column_traits<6>::rvalue_type mass	  = default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(extents_x),
						   static_cast<column_traits<4>::rvalue_forward_type>(extents_y),
						   static_cast<column_traits<5>::rvalue_forward_type>(extents_z),
						   static_cast<column_traits<6>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		boxes& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX = column_traits<3>::default_emplace_type,
				  typename ExtentsY = column_traits<4>::default_emplace_type,
				  typename ExtentsZ = column_traits<5>::default_emplace_type,
				  typename Mass		= column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(boxes&, sfinae) emplace(size_type index_,
												   CenterX&& center_x,
												   CenterY&& center_y,
												   CenterZ&& center_z,
												   ExtentsX&& extents_x = 0.5,
												   ExtentsY&& extents_y = 0.5,
												   ExtentsZ&& extents_z = 0.5,
												   Mass&& mass			= default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX = column_traits<3>::default_emplace_type,
				  typename ExtentsY = column_traits<4>::default_emplace_type,
				  typename ExtentsZ = column_traits<5>::default_emplace_type,
				  typename Mass		= column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) emplace(iterator iter_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 ExtentsX&& extents_x = 0.5,
													 ExtentsY&& extents_y = 0.5,
													 ExtentsZ&& extents_z = 0.5,
													 Mass&& mass		  = default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename ExtentsX = column_traits<3>::default_emplace_type,
				  typename ExtentsY = column_traits<4>::default_emplace_type,
				  typename ExtentsZ = column_traits<5>::default_emplace_type,
				  typename Mass		= column_traits<6>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) emplace(const_iterator iter_,
														   CenterX&& center_x,
														   CenterY&& center_y,
														   CenterZ&& center_z,
														   ExtentsX&& extents_x = 0.5,
														   ExtentsY&& extents_y = 0.5,
														   ExtentsZ&& extents_z = 0.5,
														   Mass&& mass			= default_mass) //
			noexcept(table_traits::emplace_is_nothrow<table_type&,
													  CenterX&&,
													  CenterY&&,
													  CenterZ&&,
													  ExtentsX&&,
													  ExtentsY&&,
													  ExtentsZ&&,
													  Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<ExtentsX&&>(extents_x),
						   static_cast<ExtentsY&&>(extents_y),
						   static_cast<ExtentsZ&&>(extents_z),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

#endif

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const boxes& lhs, const boxes& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

#endif

		/// @}

		/// @name Column access
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() //
			noexcept(soagen::has_nothrow_data_member<table_type>);

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() //
			noexcept(soagen::has_nothrow_data_member<const table_type>);

#endif

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr float* center_x() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const float* center_x() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr float* center_y() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const float* center_y() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr float* center_z() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const float* center_z() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: extents_x.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr float* extents_x() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: extents_x.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const float* extents_x() const noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [4]: extents_y.
		SOAGEN_ALIGNED_COLUMN(4)
		constexpr float* extents_y() noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [4]: extents_y.
		SOAGEN_ALIGNED_COLUMN(4)
		constexpr const float* extents_y() const noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [5]: extents_z.
		SOAGEN_ALIGNED_COLUMN(5)
		constexpr float* extents_z() noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [5]: extents_z.
		SOAGEN_ALIGNED_COLUMN(5)
		constexpr const float* extents_z() const noexcept
		{
			return column<5>();
		}

		/// @brief Returns a pointer to the elements in column [6]: mass.
		SOAGEN_ALIGNED_COLUMN(6)
		constexpr float* mass() noexcept
		{
			return column<6>();
		}

		/// @brief Returns a pointer to the elements in column [6]: mass.
		SOAGEN_ALIGNED_COLUMN(6)
		constexpr const float* mass() const noexcept
		{
			return column<6>();
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<6>(), size_type{ 6 });
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<5>(), size_type{ 5 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<6>(), size_type{ 6 });
		}

		/// @}

		/// @name Row access
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<boxes&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5, 6>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<boxes&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<static_cast<size_type>(Columns)>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4, 5, 6>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const boxes&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4, 5, 6>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<boxes&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const boxes&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @}
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::boxes.
	///
	/// @availability	This overload is only available when #soagen::examples::boxes::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<boxes>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(boxes& lhs, boxes& rhs) //
		noexcept(soagen::has_nothrow_swap_member<boxes>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

//----------------------------------------------------------------------------------------------------------------------
// spheres
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief A SIMD-friendly bounding sphere container.
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct spheres
	/// {
	/// 	float center_x;
	/// 	float center_y;
	/// 	float center_z;
	/// 	float radius;
	/// 	float mass;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES spheres //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::resizable<spheres>,
						   public soagen::mixins::equality_comparable<spheres>,
						   public soagen::mixins::less_than_comparable<spheres>,
						   public soagen::mixins::data_ptr<spheres>,
						   public soagen::mixins::const_data_ptr<spheres>,
						   public soagen::mixins::swappable<spheres>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<spheres>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<spheres>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<spheres>;

		/// @brief The number of columns in the table.
		static constexpr size_type column_count = soagen::table_traits_type<spheres>::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		/// @brief Gets the type of a specific column in the table.
		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<spheres&>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::iterator_type<const spheres&>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::iterator_type<spheres&&>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<spheres&>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::row_type<const spheres&>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::row_type<spheres&&>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using columns = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		enum class columns : size_type
		{
			center_x = 0,
			center_y = 1,
			center_z = 2,
			radius	 = 3,
			mass	 = 4,
		};
#endif

		/// @brief Gets the name of the specified column as a null-terminated string.
		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<spheres, static_cast<size_type>(Column)>::value;

		static constexpr float default_mass = 1.0;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		spheres() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(spheres&&) = default;

		/// @brief Move-assignment operator.
		spheres& operator=(spheres&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		spheres(const spheres&) = default;

		/// @brief Copy-assignment operator.
		spheres& operator=(const spheres&) = default;

		/// @brief Destructor.
		~spheres() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit spheres(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table access
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		///
		/// @warning This value is `capacity() * (sizeof() for every column) + (alignment padding)`.
		/// It is **not** based on `size()`! If you are using the value returned by this function
		/// in conjunction with `data()` to do serialization, hashing, etc, use `shrink_to_fit()` first.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		/// @brief Swaps two columns.
		///
		/// @availability The two columns must have the same underlying value_type.
		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		spheres& swap_columns() //
			noexcept(noexcept(
				std::declval<table_type&>().template swap_columns<static_cast<size_t>(A), static_cast<size_t>(B)>()))
		{
			table_.template swap_columns<static_cast<size_t>(A), static_cast<size_t>(B)>();
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		spheres& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type, size_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(spheres& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(column_traits<0>::param_type center_x,
						   column_traits<1>::param_type center_y,
						   column_traits<2>::param_type center_z,
						   column_traits<3>::param_type radius = 0.5,
						   column_traits<4>::param_type mass   = default_mass) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(center_x),
								static_cast<column_traits<1>::param_forward_type>(center_y),
								static_cast<column_traits<2>::param_forward_type>(center_z),
								static_cast<column_traits<3>::param_forward_type>(radius),
								static_cast<column_traits<4>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN(template <bool sfinae = table_traits::rvalue_type_list_is_distinct>)
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(SOAGEN_ENABLE_IF_T(column_traits<0>::rvalue_type, sfinae) center_x,
						   column_traits<1>::rvalue_type center_y,
						   column_traits<2>::rvalue_type center_z,
						   column_traits<3>::rvalue_type radius = 0.5,
						   column_traits<4>::rvalue_type mass	= default_mass) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct)	  //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(center_x),
								static_cast<column_traits<1>::rvalue_forward_type>(center_y),
								static_cast<column_traits<2>::rvalue_forward_type>(center_z),
								static_cast<column_traits<3>::rvalue_forward_type>(radius),
								static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return *this;
		}

		/// @brief Adds a new row at the end of the table.
		template <typename Table, auto... Columns SOAGEN_ENABLE_IF(soagen::is_soa<soagen::remove_cvref<Table>>)>
		SOAGEN_CPP20_CONSTEXPR
		spheres& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius = column_traits<3>::default_emplace_type,
				  typename Mass	  = column_traits<4>::default_emplace_type>
		SOAGEN_CPP20_CONSTEXPR
		spheres& emplace_back(CenterX&& center_x,
							  CenterY&& center_y,
							  CenterZ&& center_z,
							  Radius&& radius = 0.5,
							  Mass&& mass	  = default_mass) //
			noexcept(
				table_traits::emplace_back_is_nothrow<table_type&, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>)
		{
			table_.emplace_back(static_cast<CenterX&&>(center_x),
								static_cast<CenterY&&>(center_y),
								static_cast<CenterZ&&>(center_z),
								static_cast<Radius&&>(radius),
								static_cast<Mass&&>(mass));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move-constructible and move-assignable.
		/// @{

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) insert(size_type index_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type radius = 0.5,
													column_traits<4>::param_type mass	= default_mass)	  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type center_x,
													column_traits<1>::param_type center_y,
													column_traits<2>::param_type center_z,
													column_traits<3>::param_type radius = 0.5,
													column_traits<4>::param_type mass	= default_mass)	  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type center_x,
														  column_traits<1>::param_type center_y,
														  column_traits<2>::param_type center_z,
														  column_traits<3>::param_type radius = 0.5,
														  column_traits<4>::param_type mass	  = default_mass) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)	//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(center_x),
						   static_cast<column_traits<1>::param_forward_type>(center_y),
						   static_cast<column_traits<2>::param_forward_type>(center_z),
						   static_cast<column_traits<3>::param_forward_type>(radius),
						   static_cast<column_traits<4>::param_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type radius = 0.5,
						column_traits<4>::rvalue_type mass	 = default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type center_x,
						column_traits<1>::rvalue_type center_y,
						column_traits<2>::rvalue_type center_z,
						column_traits<3>::rvalue_type radius = 0.5,
						column_traits<4>::rvalue_type mass	 = default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type center_x,
							  column_traits<1>::rvalue_type center_y,
							  column_traits<2>::rvalue_type center_z,
							  column_traits<3>::rvalue_type radius = 0.5,
							  column_traits<4>::rvalue_type mass   = default_mass) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(center_x),
						   static_cast<column_traits<1>::rvalue_forward_type>(center_y),
						   static_cast<column_traits<2>::rvalue_forward_type>(center_z),
						   static_cast<column_traits<3>::rvalue_forward_type>(radius),
						   static_cast<column_traits<4>::rvalue_forward_type>(mass));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		spheres& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  auto... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													&& table_traits::all_move_constructible
													&& table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius = column_traits<3>::default_emplace_type,
				  typename Mass	  = column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
						bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(spheres&, sfinae) emplace(size_type index_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 Radius&& radius = 0.5,
													 Mass&& mass	 = default_mass)						  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius = column_traits<3>::default_emplace_type,
				  typename Mass	  = column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
						bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) emplace(iterator iter_,
													 CenterX&& center_x,
													 CenterY&& center_y,
													 CenterZ&& center_z,
													 Radius&& radius = 0.5,
													 Mass&& mass	 = default_mass)						  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename CenterX,
				  typename CenterY,
				  typename CenterZ,
				  typename Radius = column_traits<3>::default_emplace_type,
				  typename Mass	  = column_traits<4>::default_emplace_type SOAGEN_HIDDEN_PARAM(
						bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) emplace(const_iterator iter_,
														   CenterX&& center_x,
														   CenterY&& center_y,
														   CenterZ&& center_z,
														   Radius&& radius = 0.5,
														   Mass&& mass	   = default_mass)					  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, CenterX&&, CenterY&&, CenterZ&&, Radius&&, Mass&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<CenterX&&>(center_x),
						   static_cast<CenterY&&>(center_y),
						   static_cast<CenterZ&&>(center_z),
						   static_cast<Radius&&>(radius),
						   static_cast<Mass&&>(mass));
			return iter_;
		}

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

#endif

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const spheres& lhs, const spheres& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

#endif

		/// @}

		/// @name Column access
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() //
			noexcept(soagen::has_nothrow_data_member<table_type>);

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() //
			noexcept(soagen::has_nothrow_data_member<const table_type>);

#endif

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr float* center_x() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: center_x.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const float* center_x() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr float* center_y() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: center_y.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const float* center_y() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr float* center_z() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: center_z.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const float* center_z() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: radius.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr float* radius() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: radius.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const float* radius() const noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [4]: mass.
		SOAGEN_ALIGNED_COLUMN(4)
		constexpr float* mass() noexcept
		{
			return column<4>();
		}

		/// @brief Returns a pointer to the elements in column [4]: mass.
		SOAGEN_ALIGNED_COLUMN(4)
		constexpr const float* mass() const noexcept
		{
			return column<4>();
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
		}

		/// @}

		/// @name Row access
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<spheres&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<spheres&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<static_cast<size_type>(Columns)>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const spheres&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<spheres&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const spheres&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @}
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::spheres.
	///
	/// @availability	This overload is only available when #soagen::examples::spheres::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<spheres>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(spheres& lhs, spheres& rhs) //
		noexcept(soagen::has_nothrow_swap_member<spheres>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
