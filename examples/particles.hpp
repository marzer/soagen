//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen - do not modify it directly
// https://github.com/marzer/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// \file
/// \brief Contains the definition of foo::particles.

#include <soagen.hpp>

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations
//----------------------------------------------------------------------------------------------------------------------

/// \cond

namespace foo
{
	class particles;
}

/// \endcond

//----------------------------------------------------------------------------------------------------------------------
// particles
//----------------------------------------------------------------------------------------------------------------------

namespace foo
{
	/// \addtogroup soa Struct-of-Arrays
	/// @{

	/// \addtogroup soa_particles particles
	/// @{

	/// \brief particles
	class particles
	{
	  public:
		using size_type		  = std::size_t;
		using difference_type = std::ptrdiff_t;
		using allocator_type  = soagen::allocator;

		using table_traits =
			soagen::table_traits<soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float, soagen::detail::col_default_param_type<float>, 32>,
								 soagen::column_traits<float>>;

		template <size_type I>
		using column_traits = typename table_traits::template column<I>;

		template <size_type I>
		using column_type = typename column_traits<I>::value_type;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		struct column_indices
		{
			static constexpr size_type position_x = 0;
			static constexpr size_type position_y = 1;
			static constexpr size_type position_z = 2;
			static constexpr size_type velocity_x = 3;
			static constexpr size_type velocity_y = 4;
			static constexpr size_type velocity_z = 5;
			static constexpr size_type mass		  = 6;
		};

		template <size_type>
		static constexpr const char column_name[] = "";
		template <>
		static constexpr const char column_name<0>[] = "position_x";
		template <>
		static constexpr const char column_name<1>[] = "position_y";
		template <>
		static constexpr const char column_name<2>[] = "position_z";
		template <>
		static constexpr const char column_name<3>[] = "velocity_x";
		template <>
		static constexpr const char column_name<4>[] = "velocity_y";
		template <>
		static constexpr const char column_name<5>[] = "velocity_z";
		template <>
		static constexpr const char column_name<6>[] = "mass";

		static constexpr float default_mass = 500.0;

	  private:
		/// \cond

		using table_type = soagen::table<table_traits, allocator_type>;
		table_type table_;

		/// \endcond

	  public:
		SOAGEN_NODISCARD_CTOR
		particles() = default;

		SOAGEN_NODISCARD_CTOR
		particles(const particles&) = default;

		SOAGEN_NODISCARD_CTOR
		particles(particles&&) = default;

		particles& operator=(const particles&) = default;

		particles& operator=(particles&&) = default;

		~particles() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit particles(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void clear() noexcept
		{
			return table_.clear();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void reserve(size_type new_cap) noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void shrink_to_fit() noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		void pop_back(size_type num = 1) noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
		}

		SOAGEN_INLINE_GETTER
		constexpr allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		constexpr void swap(particles& other) //
			noexcept(noexcept(std::declval<table_type&>().swap(std::declval<table_type&>())))
		{
			table_.swap(other.table_);
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_swap_member<particles>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(particles& lhs, particles& rhs) //
		noexcept(noexcept(std::declval<particles&>().swap(std::declval<particles&>())))
	{
		lhs.swap(rhs);
	}

	static_assert(std::is_default_constructible_v<particles> == particles::table_traits::all_default_constructible);
	static_assert(std::is_move_constructible_v<particles> == particles::table_traits::all_move_constructible);
	static_assert(std::is_move_assignable_v<particles> == particles::table_traits::all_move_assignable);
	static_assert(std::is_copy_constructible_v<particles> == particles::table_traits::all_copy_constructible);
	static_assert(std::is_copy_assignable_v<particles> == particles::table_traits::all_copy_assignable);
	static_assert(std::is_nothrow_destructible_v<particles>);

	/// \cond

	/// \endcond

	/// @}

	/// @}
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
