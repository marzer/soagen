//----------------------------------------------------------------------------------------------------------------------
// This file is a part of marzer/soagen and is subject to the the terms of the MIT license.
// Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/soagen/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.1.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// @file
/// @brief Contains the definition of soagen::examples::entities.
///
/// @note The code and documentation in this file were generated by soagen - https://marzer.github.io/soagen

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 1
	#error soagen version mismatch - expected v0.1.X
#endif

SOAGEN_DISABLE_WARNINGS;
#include <string>
#if SOAGEN_HAS_EXCEPTIONS
	#include <stdexcept>
#endif
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_CLANG >= 16
	#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// doxygen safeguards
//----------------------------------------------------------------------------------------------------------------------

#if defined(DOXYGEN) || defined(__DOXYGEN) || defined(__DOXYGEN__) || defined(__doxygen__) || defined(__POXY__)        \
	|| defined(__poxy__)

	#ifndef SOAGEN_DOXYGEN
		#define SOAGEN_DOXYGEN 1
	#endif
	#ifndef SOAGEN_MAKE_NAME
		#define SOAGEN_MAKE_NAME(...) static_assert(true)
	#endif
	#ifndef SOAGEN_MAKE_COL
		#define SOAGEN_MAKE_COL(...) static_assert(true)
	#endif
	#ifndef SOAGEN_NODISCARD
		#define SOAGEN_NODISCARD
	#endif
	#ifndef SOAGEN_NODISCARD_CTOR
		#define SOAGEN_NODISCARD_CTOR
	#endif
	#ifndef SOAGEN_INLINE_GETTER
		#define SOAGEN_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_PURE_GETTER
		#define SOAGEN_PURE_GETTER
	#endif
	#ifndef SOAGEN_PURE_INLINE_GETTER
		#define SOAGEN_PURE_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_ALWAYS_INLINE
		#define SOAGEN_ALWAYS_INLINE inline
	#endif
	#ifndef SOAGEN_CPP20_CONSTEXPR
		#define SOAGEN_CPP20_CONSTEXPR constexpr
	#endif
	#ifndef SOAGEN_HIDDEN
		#define SOAGEN_HIDDEN(...)
	#endif
	#ifndef SOAGEN_HIDDEN_BASE
		#define SOAGEN_HIDDEN_BASE(...)
	#endif
	#ifndef SOAGEN_HIDDEN_CONSTRAINT
		#define SOAGEN_HIDDEN_CONSTRAINT(...)
	#endif
	#ifndef SOAGEN_HIDDEN_PARAM
		#define SOAGEN_HIDDEN_PARAM(...)
	#endif
	#ifndef SOAGEN_ENABLE_IF_T
		#define SOAGEN_ENABLE_IF_T(T, ...) T
	#endif
	#ifndef SOAGEN_ENABLE_IF
		#define SOAGEN_ENABLE_IF(...)
	#endif
	#ifndef SOAGEN_REQUIRES
		#define SOAGEN_REQUIRES(...)
	#endif
	#ifndef SOAGEN_EMPTY_BASES
		#define SOAGEN_EMPTY_BASES
	#endif
	#ifndef SOAGEN_COLUMN
		#define SOAGEN_COLUMN(...)
	#endif
	#ifndef SOAGEN_ALIGNED_COLUMN
		#define SOAGEN_ALIGNED_COLUMN(...)
	#endif
	#if !defined(POXY_IMPLEMENTATION_DETAIL) && !(defined(__POXY__) || defined(__poxy__))
		#define POXY_IMPLEMENTATION_DETAIL(...) __VA_ARGS__
	#endif

#endif // doxygen

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

/// @cond

namespace soagen::examples
{
	class entities;
}

namespace soagen
{
	template <>
	inline constexpr bool is_soa<soagen::examples::entities> = true;
}

namespace soagen::detail
{
	// clang-format off

	#ifndef SOAGEN_NAME_id
		#define SOAGEN_NAME_id
		SOAGEN_MAKE_NAME(id);
	#endif

	#ifndef SOAGEN_NAME_name
		#define SOAGEN_NAME_name
		SOAGEN_MAKE_NAME(name);
	#endif

	#ifndef SOAGEN_NAME_orient
		#define SOAGEN_NAME_orient
		SOAGEN_MAKE_NAME(orient);
	#endif

	#ifndef SOAGEN_NAME_pos
		#define SOAGEN_NAME_pos
		SOAGEN_MAKE_NAME(pos);
	#endif

	// clang-format on

	template <>
	struct table_traits_type_<soagen::examples::entities>
	{
		using type = table_traits<
			/*	   id */ make_column<unsigned>,
			/*	 name */ make_column<std::string>,
			/*	  pos */ make_column<vec3, param_type<vec3>, 32>,
			/* orient */ make_column<quaternion>>;
	};

	template <>
	struct allocator_type_<soagen::examples::entities>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COL(soagen::examples::entities, 0, id);
	SOAGEN_MAKE_COL(soagen::examples::entities, 1, name);
	SOAGEN_MAKE_COL(soagen::examples::entities, 2, pos);
	SOAGEN_MAKE_COL(soagen::examples::entities, 3, orient);

	template <>
	struct table_type_<soagen::examples::entities>
	{
		using type = table<table_traits_type<soagen::examples::entities>, soagen::allocator>;
	};
}

/// @endcond

//----------------------------------------------------------------------------------------------------------------------
// entities
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief entities
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct entities
	/// {
	/// 	unsigned id;
	/// 	std::string name;
	/// 	vec3 pos;
	/// 	quaternion orient;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES entities //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::resizable<entities>,
						   public soagen::mixins::equality_comparable<entities>,
						   public soagen::mixins::less_than_comparable<entities>,
						   public soagen::mixins::data_ptr<entities>,
						   public soagen::mixins::const_data_ptr<entities>,
						   public soagen::mixins::swappable<entities>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<entities>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<entities>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<entities>;

		/// @brief The number of columns in the table.
		static constexpr size_t column_count = soagen::table_traits_type<entities>::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <size_type Column>
		using column_traits = typename table_traits::template column<Column>;

		/// @brief Gets the type of a specific column in the table.
		template <size_type Column>
		using column_type = typename column_traits<Column>::value_type;

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<entities&>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::iterator_type<const entities&>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::iterator_type<entities&&>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<entities&>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::row_type<const entities&>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::row_type<entities&&>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using column_indices = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		struct column_indices
		{
			static constexpr size_type id	  = 0;
			static constexpr size_type name	  = 1;
			static constexpr size_type pos	  = 2;
			static constexpr size_type orient = 3;
		};
#endif

		/// @brief Gets the name of the specified column as a string.
		template <size_type Column>
		static constexpr auto& column_name = soagen::detail::col_name_<entities, Column>::value;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		entities() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		entities(entities&&) = default;

		/// @brief Move-assignment operator.
		entities& operator=(entities&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		entities(const entities&) = default;

		/// @brief Copy-assignment operator.
		entities& operator=(const entities&) = default;

		/// @brief Destructor.
		~entities() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit entities(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit entities(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table access
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @}

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		/// @brief Reserves storage for (at least) the given number of rows.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		entities& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		/// @brief Returns the number of rows that can be held in currently allocated storage.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		/// @brief Frees unused capacity.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		entities& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Removes all rows from table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		entities& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(entities&, sfinae) erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Removes the last row(s) from the table.
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		entities& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		entities& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type, size_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(entities& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		entities& push_back(column_traits<0>::param_type id,
							column_traits<1>::param_type name	= "",
							column_traits<2>::param_type pos	= {},
							column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(id),
								static_cast<column_traits<1>::param_forward_type>(name),
								static_cast<column_traits<2>::param_forward_type>(pos),
								static_cast<column_traits<3>::param_forward_type>(orient));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN(template <bool sfinae = table_traits::rvalue_type_list_is_distinct>)
		SOAGEN_CPP20_CONSTEXPR
		entities& push_back(SOAGEN_ENABLE_IF_T(column_traits<0>::rvalue_type, sfinae) id,
							column_traits<1>::rvalue_type name	 = "",
							column_traits<2>::rvalue_type pos	 = {},
							column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct)		   //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(id),
								static_cast<column_traits<1>::rvalue_forward_type>(name),
								static_cast<column_traits<2>::rvalue_forward_type>(pos),
								static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return *this;
		}

		/// @brief Adds a new row at the end of the table.
		template <typename Table, size_t... Columns SOAGEN_ENABLE_IF(soagen::is_soa<soagen::remove_cvref<Table>>)>
		SOAGEN_CPP20_CONSTEXPR
		entities& push_back(const soagen::row<Table, Columns...>& row_)		 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type>
		SOAGEN_CPP20_CONSTEXPR
		entities& emplace_back(Id&& id, Name&& name = "", Pos&& pos = {}, Orient&& orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
		{
			table_.emplace_back(static_cast<Id&&>(id),
								static_cast<Name&&>(name),
								static_cast<Pos&&>(pos),
								static_cast<Orient&&>(orient));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move-constructible and move-assignable.
		/// @{

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(entities&, sfinae) insert(size_type index_,
													 column_traits<0>::param_type id,
													 column_traits<1>::param_type name	 = "",
													 column_traits<2>::param_type pos	 = {},
													 column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)  //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type id,
													column_traits<1>::param_type name	= "",
													column_traits<2>::param_type pos	= {},
													column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type id,
														  column_traits<1>::param_type name	  = "",
														  column_traits<2>::param_type pos	  = {},
														  column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable)		//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		entities& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
						 column_traits<0>::rvalue_type id,
						 column_traits<1>::rvalue_type name	  = "",
						 column_traits<2>::rvalue_type pos	  = {},
						 column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type id,
						column_traits<1>::rvalue_type name	 = "",
						column_traits<2>::rvalue_type pos	 = {},
						column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type id,
							  column_traits<1>::rvalue_type name   = "",
							  column_traits<2>::rvalue_type pos	   = {},
							  column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  size_t... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													  && table_traits::all_move_constructible
													  && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		entities& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  size_t... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													  && table_traits::all_move_constructible
													  && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Table,
				  size_t... Columns SOAGEN_ENABLE_IF((soagen::is_soa<soagen::remove_cvref<Table>>
													  && table_traits::all_move_constructible
													  && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(entities&, sfinae) emplace(size_type index_,
													  Id&& id,
													  Name&& name	  = "",
													  Pos&& pos		  = {},
													  Orient&& orient = { 1, 0, 0, 0 })					  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) emplace(iterator iter_,
													 Id&& id,
													 Name&& name	 = "",
													 Pos&& pos		 = {},
													 Orient&& orient = { 1, 0, 0, 0 })					  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_HIDDEN_PARAM(
					  bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable))>
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) emplace(const_iterator iter_,
														   Id&& id,
														   Name&& name	   = "",
														   Pos&& pos	   = {},
														   Orient&& orient = { 1, 0, 0, 0 })			  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return iter_;
		}

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

#endif

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

#endif

		/// @}

		/// @name Column access
		/// @{

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() //
			noexcept(soagen::has_nothrow_data_member<table_type>);

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() //
			noexcept(soagen::has_nothrow_data_member<const table_type>);

#endif

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <size_type Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(Column < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, Column>>(
				table_.template column<Column>());
		}

		/// @brief Returns a pointer to the elements in column [0]: id.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr unsigned* id() noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [0]: id.
		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const unsigned* id() const noexcept
		{
			return column<0>();
		}

		/// @brief Returns a pointer to the elements in column [1]: name.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr std::string* name() noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [1]: name.
		SOAGEN_ALIGNED_COLUMN(1)
		constexpr const std::string* name() const noexcept
		{
			return column<1>();
		}

		/// @brief Returns a pointer to the elements in column [2]: pos.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr vec3* pos() noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [2]: pos.
		SOAGEN_ALIGNED_COLUMN(2)
		constexpr const vec3* pos() const noexcept
		{
			return column<2>();
		}

		/// @brief Returns a pointer to the elements in column [3]: orient.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr quaternion* orient() noexcept
		{
			return column<3>();
		}

		/// @brief Returns a pointer to the elements in column [3]: orient.
		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const quaternion* orient() const noexcept
		{
			return column<3>();
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
		}

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<br>
		/// - `void(auto*, size_type)`
		/// - `void(size_type, auto*)`
		/// - `void(auto*)`
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
		}

		/// @}

		/// @name Row access
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<entities&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<entities&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<Columns>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <size_type... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const entities&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<Columns>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3>(index);
			}
		}

		/// @brief Returns the row at the given index.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		/// @brief Returns the very first row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		/// @brief Returns the very last row in the table.
		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<entities&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<entities&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<entities&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<entities&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const entities&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const entities&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @brief Returns an iterator to the first row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const entities&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const entities&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		/// @}
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::entities.
	///
	/// @availability	This overload is only available when #soagen::examples::entities::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<entities>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(entities& lhs, entities& rhs) //
		noexcept(soagen::has_nothrow_swap_member<entities>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
