//----------------------------------------------------------------------------------------------------------------------
// This file is a part of marzer/soagen and is subject to the the terms of the MIT license.
// Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
// See https://github.com/marzer/soagen/blob/master/LICENSE for the full license text.
// SPDX-License-Identifier: MIT
//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.6.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

/// @file
/// @brief Contains the definition of soagen::examples::entities.
///
/// @note The code and documentation in this file were generated by soagen - https://marzer.github.io/soagen

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 6
	#error soagen version mismatch - expected v0.6.X
#endif

SOAGEN_DISABLE_WARNINGS;
#include <string>
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// doxygen safeguards
//----------------------------------------------------------------------------------------------------------------------

#if defined(DOXYGEN) || defined(__DOXYGEN) || defined(__DOXYGEN__) || defined(__doxygen__) || defined(__POXY__)        \
	|| defined(__poxy__)

	#ifndef SOAGEN_DOXYGEN
		#define SOAGEN_DOXYGEN 1
	#endif
	#ifndef SOAGEN_MAKE_NAME
		#define SOAGEN_MAKE_NAME(...) static_assert(true)
	#endif
	#ifndef SOAGEN_MAKE_NAMED_COLUMN
		#define SOAGEN_MAKE_NAMED_COLUMN(...) static_assert(true)
	#endif
	#ifndef SOAGEN_NODISCARD
		#define SOAGEN_NODISCARD
	#endif
	#ifndef SOAGEN_NODISCARD_CTOR
		#define SOAGEN_NODISCARD_CTOR
	#endif
	#ifndef SOAGEN_INLINE_GETTER
		#define SOAGEN_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_PURE_GETTER
		#define SOAGEN_PURE_GETTER
	#endif
	#ifndef SOAGEN_PURE_INLINE_GETTER
		#define SOAGEN_PURE_INLINE_GETTER inline
	#endif
	#ifndef SOAGEN_ALWAYS_INLINE
		#define SOAGEN_ALWAYS_INLINE inline
	#endif
	#ifndef SOAGEN_CPP20_CONSTEXPR
		#define SOAGEN_CPP20_CONSTEXPR constexpr
	#endif
	#ifndef SOAGEN_HIDDEN
		#define SOAGEN_HIDDEN(...)
	#endif
	#ifndef SOAGEN_HIDDEN_BASE
		#define SOAGEN_HIDDEN_BASE(...)
	#endif
	#ifndef SOAGEN_HIDDEN_CONSTRAINT
		#define SOAGEN_HIDDEN_CONSTRAINT(...)
	#endif
	#ifndef SOAGEN_HIDDEN_PARAM
		#define SOAGEN_HIDDEN_PARAM(...)
	#endif
	#ifndef SOAGEN_ENABLE_IF_T
		#define SOAGEN_ENABLE_IF_T(T, ...) T
	#endif
	#ifndef SOAGEN_ENABLE_IF
		#define SOAGEN_ENABLE_IF(...)
	#endif
	#ifndef SOAGEN_REQUIRES
		#define SOAGEN_REQUIRES(...)
	#endif
	#ifndef SOAGEN_EMPTY_BASES
		#define SOAGEN_EMPTY_BASES
	#endif
	#ifndef SOAGEN_COLUMN
		#define SOAGEN_COLUMN(...)
	#endif
	#if !defined(POXY_IMPLEMENTATION_DETAIL) && !(defined(__POXY__) || defined(__poxy__))
		#define POXY_IMPLEMENTATION_DETAIL(...) __VA_ARGS__
	#endif

#endif // doxygen

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

/// @cond

// clang-format off

namespace soagen::examples
{
	class entities;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_id
		#define SOAGEN_NAME_id
		SOAGEN_MAKE_NAME(id);
	#endif

	#ifndef SOAGEN_NAME_name
		#define SOAGEN_NAME_name
		SOAGEN_MAKE_NAME(name);
	#endif

	#ifndef SOAGEN_NAME_orient
		#define SOAGEN_NAME_orient
		SOAGEN_MAKE_NAME(orient);
	#endif

	#ifndef SOAGEN_NAME_pos
		#define SOAGEN_NAME_pos
		SOAGEN_MAKE_NAME(pos);
	#endif

	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::entities, 0, id);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::entities, 1, name);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::entities, 2, pos);
	SOAGEN_MAKE_NAMED_COLUMN(soagen::examples::entities, 3, orient);

	template <>
	struct is_soa_<soagen::examples::entities> : std::true_type
	{};

	template <>
	struct table_traits_type_<soagen::examples::entities>
	{
		using type = table_traits<
		/*	   id */ column_traits<unsigned>,
		/*	 name */ column_traits<std::string>,
		/*	  pos */ column_traits<vec3, soagen::max(size_t{ 32 }, alignof(vec3))>,
		/* orient */ column_traits<quaternion>>;
	};

	template <>
	struct allocator_type_<soagen::examples::entities>
	{
		using type = soagen::allocator;
	};

	template <>
	struct table_type_<soagen::examples::entities>
	{
		using type = table<table_traits_type<soagen::examples::entities>, allocator_type<soagen::examples::entities>>;
	};
}

// clang-format on

/// @endcond

//----------------------------------------------------------------------------------------------------------------------
// entities
//----------------------------------------------------------------------------------------------------------------------

namespace soagen::examples
{
	/// @brief entities
	///
	/// @details
	///
	/// @remark Models the <a href="https://en.wikipedia.org/wiki/AoS_and_SoA">Structure-of-arrays</a>
	/// equivalent of: @code{.cpp}
	/// struct entities
	/// {
	/// 	unsigned id;
	/// 	std::string name;
	/// 	vec3 pos;
	/// 	quaternion orient;
	/// };
	/// @endcode
	///
	///
	/// @note The code and documentation for this class were generated by soagen - https://marzer.github.io/soagen
	class SOAGEN_EMPTY_BASES entities //
		SOAGEN_HIDDEN_BASE(public soagen::mixins::size_and_capacity<entities>,
						   public soagen::mixins::resizable<entities>,
						   public soagen::mixins::equality_comparable<entities>,
						   public soagen::mixins::less_than_comparable<entities>,
						   public soagen::mixins::data_ptr<entities>,
						   public soagen::mixins::columns<entities>,
						   public soagen::mixins::rows<entities>,
						   public soagen::mixins::iterators<entities>,
						   public soagen::mixins::spans<entities>,
						   public soagen::mixins::swappable<entities>)
	{
	  public:
		/// @brief The unsigned integer size type used by this class.
		using size_type = std::size_t;

		/// @brief The signed integer difference type used by this class.
		using difference_type = std::ptrdiff_t;

		/// @brief The allocator type used by this class.
		using allocator_type = soagen::allocator_type<entities>;

		/// @brief This class's underlying soagen::table type.
		using table_type = soagen::table_type<entities>;

		/// @brief The soagen::table_traits for the underlying table.
		using table_traits = soagen::table_traits_type<entities>;

		/// @brief The number of columns in the table.
		static constexpr size_type column_count = table_traits::column_count;

		/// @brief Gets the soagen::column_traits for a specific column of the table.
		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		/// @brief Gets the type of a specific column in the table.
		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		/// @brief Row iterators returned by iterator functions.
		using iterator = soagen::iterator_type<entities>;

		/// @brief Row iterators returned by rvalue-qualified iterator functions.
		using rvalue_iterator = soagen::iterator_type<entities&&>;

		/// @brief Row iterators returned by const-qualified iterator functions.
		using const_iterator = soagen::const_iterator_type<entities>;

		/// @brief Regular (lvalue-qualified) span type.
		using span_type = soagen::span_type<entities>;

		/// @brief Rvalue-qualified span type.
		using rvalue_span_type = soagen::span_type<entities&&>;

		/// @brief Const-qualified span type.
		using const_span_type = soagen::const_span_type<entities>;

		/// @brief Regular (lvalue-qualified) row type used by this class.
		using row_type = soagen::row_type<entities>;

		/// @brief Const row type used by this class.
		using const_row_type = soagen::row_type<const entities>;

		/// @brief Rvalue row type used by this class.
		using rvalue_row_type = soagen::row_type<entities&&>;

		/// @brief	 The number of rows to advance to maintain the requested `alignment` for every column.
		///
		/// @details The stride size you need to use when iterating through rows of this table such that
		/// the starting element for each batch in each column would have the same memory alignment as the
		/// value specified for the column-specific `alignment`.
		///
		/// @note	 Typically you can ignore this; column elements are always aligned correctly according to their
		/// type. This is for over-alignment scenarios where you need to do things in batches (e.g. SIMD).
		static constexpr size_type aligned_stride = table_traits::aligned_stride;

#if SOAGEN_DOXYGEN
		/// @brief Named index constants for all of the columns in the table.
		using columns = POXY_IMPLEMENTATION_DETAIL(struct dummy_t);
#else
		enum class columns : size_type
		{
			id	   = 0,
			name   = 1,
			pos	   = 2,
			orient = 3,
		};
#endif

		/// @brief Gets the name of the specified column as a null-terminated string.
		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<entities, static_cast<size_type>(Column)>::value;

	  private:
		/// @cond

		table_type table_;

		/// @endcond

	  public:
		/// @brief Default constructor.
		SOAGEN_NODISCARD_CTOR
		entities() = default;

		/// @brief Move constructor.
		SOAGEN_NODISCARD_CTOR
		entities(entities&&) = default;

		/// @brief Move-assignment operator.
		entities& operator=(entities&&) = default;

		/// @brief Copy constructor.
		SOAGEN_NODISCARD_CTOR
		entities(const entities&) = default;

		/// @brief Copy-assignment operator.
		entities& operator=(const entities&) = default;

		/// @brief Destructor.
		~entities() = default;

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit entities(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		/// @brief Constructs with the given allocator.
		SOAGEN_NODISCARD_CTOR
		constexpr explicit entities(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		/// @brief Returns the allocator being used by the table.
		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		/// @name Underlying table
		/// @{

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		/// @brief Returns an lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		/// @brief Returns an rvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		/// @brief Returns a const lvalue reference to the underlying soagen::table.
		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		/// @}

		/// @name Modifiers
		/// @{

		/// @brief Erases the row at the given position.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(entities&, sfinae) erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)
		{
			table_.erase(pos);
			return *this;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<size_type>, sfinae) unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)
		{
			return table_.unordered_erase(pos);
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #end() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<iterator>, sfinae) unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Erases the row at the given iterator.
		///
		/// @returns	An iterator to the row immediately following the one which was removed,
		/// or #cend() if the one removed was the last row in the table.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		/// @brief	Erases the row at the given position without preserving order.
		///
		/// @details	This is much faster than #erase() because it uses the swap-and-pop idiom:
		/// Instead of shifting all the higher rows downward, the last row is moved into the
		/// position of the erased one and the size of the table is reduced by 1.
		///
		/// @note		If you are tracking row indices in some other place and need to maintain that invariant,
		/// you can use the return value to update your data accordingly.
		///
		/// @returns	The position of the row that was moved into the erased row's position, if any.
		///
		/// @availability This method is only available when all the column types are move-assignable.
		SOAGEN_HIDDEN(template <bool sfinae = soagen::has_unordered_erase_member<table_type>>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(soagen::optional<const_iterator>, sfinae) unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		/// @brief Swaps two columns.
		///
		/// @availability The two columns must have the same underlying value_type.
		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		entities& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

#if SOAGEN_DOXYGEN

		/// @brief Removes the last row(s) from the table.
		entities& pop_back(size_type num = 1) noexcept(...);

		/// @brief Removes all rows from table.
		entities& clear() noexcept;

		/// @brief Resizes the table to the given number of rows.
		///
		/// @availability This method is only available when all the column types are default-constructible.
		entities& resize(size_type new_size) //
			noexcept(soagen::has_nothrow_resize_member<table_type>);

		/// @brief Swaps the contents of the table with another.
		///
		/// @availability This method is only available when #allocator_type is swappable or non-propagating.
		constexpr void swap(entities& other) //
			noexcept(soagen::has_nothrow_swap_member<table_type>);

#endif

		/// @}

		/// @name Adding rows
		/// @{

		/// @brief Adds a new row at the end of the table.
		SOAGEN_CPP20_CONSTEXPR
		entities& push_back(column_traits<0>::param_type id,
							column_traits<1>::param_type name	= "",
							column_traits<2>::param_type pos	= {},
							column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(id),
								static_cast<column_traits<1>::param_forward_type>(name),
								static_cast<column_traits<2>::param_forward_type>(pos),
								static_cast<column_traits<3>::param_forward_type>(orient));
			return *this;
		}

		/// @brief Adds a new row at the end of the table (rvalue overload).
		SOAGEN_HIDDEN(template <bool sfinae = table_traits::rvalue_type_list_is_distinct>)
		SOAGEN_CPP20_CONSTEXPR
		entities& push_back(SOAGEN_ENABLE_IF_T(column_traits<0>::rvalue_type, sfinae) id,
							column_traits<1>::rvalue_type name	 = "",
							column_traits<2>::rvalue_type pos	 = {},
							column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(id),
								static_cast<column_traits<1>::rvalue_forward_type>(name),
								static_cast<column_traits<2>::rvalue_forward_type>(pos),
								static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_ENABLE_IF(
					  table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>)>
		SOAGEN_CPP20_CONSTEXPR
		entities& emplace_back(Id&& id, Name&& name = "", Pos&& pos = {}, Orient&& orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>) //
		{
			table_.emplace_back(static_cast<Id&&>(id),
								static_cast<Name&&>(name),
								static_cast<Pos&&>(pos),
								static_cast<Orient&&>(orient));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at the end of the table by unpacking a tuple-like object.
		template <typename Tuple SOAGEN_ENABLE_IF(
			(table_traits::row_constructible_from<Tuple&&> && table_traits::row_constructible_from<Tuple&&>))>
		SOAGEN_CPP20_CONSTEXPR
		entities& emplace_back(Tuple&& tuple_) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&, Tuple&&>) SOAGEN_REQUIRES(
				table_traits::row_constructible_from<Tuple&&>&& table_traits::row_constructible_from<Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

		/// @}

		/// @name Inserting rows
		/// @availability These overloads are only available when all the column types are move-constructible and move-assignable.
		/// @{

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(entities&, sfinae) insert(size_type index_,
													 column_traits<0>::param_type id,
													 column_traits<1>::param_type name	 = "",
													 column_traits<2>::param_type pos	 = {},
													 column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(iterator, sfinae) insert(iterator iter_,
													column_traits<0>::param_type id,
													column_traits<1>::param_type name	= "",
													column_traits<2>::param_type pos	= {},
													column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		SOAGEN_ENABLE_IF_T(const_iterator, sfinae) insert(const_iterator iter_,
														  column_traits<0>::param_type id,
														  column_traits<1>::param_type name	  = "",
														  column_traits<2>::param_type pos	  = {},
														  column_traits<3>::param_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(id),
						   static_cast<column_traits<1>::param_forward_type>(name),
						   static_cast<column_traits<2>::param_forward_type>(pos),
						   static_cast<column_traits<3>::param_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		entities& insert(SOAGEN_ENABLE_IF_T(size_type, sfinae) index_,
						 column_traits<0>::rvalue_type id,
						 column_traits<1>::rvalue_type name	  = "",
						 column_traits<2>::rvalue_type pos	  = {},
						 column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return *this;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(SOAGEN_ENABLE_IF_T(iterator, sfinae) iter_,
						column_traits<0>::rvalue_type id,
						column_traits<1>::rvalue_type name	 = "",
						column_traits<2>::rvalue_type pos	 = {},
						column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return iter_;
		}

		/// @brief Inserts a new row at an arbitrary position in the table (rvalue overload).
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		SOAGEN_HIDDEN(
			template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
									 && table_traits::all_move_assignable)>
		)
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(SOAGEN_ENABLE_IF_T(const_iterator, sfinae) iter_,
							  column_traits<0>::rvalue_type id,
							  column_traits<1>::rvalue_type name   = "",
							  column_traits<2>::rvalue_type pos	   = {},
							  column_traits<3>::rvalue_type orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(id),
						   static_cast<column_traits<1>::rvalue_forward_type>(name),
						   static_cast<column_traits<2>::rvalue_forward_type>(pos),
						   static_cast<column_traits<3>::rvalue_forward_type>(orient));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_ENABLE_IF(
					  (table_traits::all_move_constructible && table_traits::all_move_assignable
					   && table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>))>
		SOAGEN_CPP20_CONSTEXPR
		entities& emplace(size_type index_,
						  Id&& id,
						  Name&& name	  = "",
						  Pos&& pos		  = {},
						  Orient&& orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable&&
									table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>) //
		{
			table_.emplace(index_,
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_ENABLE_IF(
					  (table_traits::all_move_constructible && table_traits::all_move_assignable
					   && table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>))>
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(iterator iter_, Id&& id, Name&& name = "", Pos&& pos = {}, Orient&& orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable&&
									table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Id,
				  typename Name	  = column_traits<1>::default_emplace_type,
				  typename Pos	  = column_traits<2>::default_emplace_type,
				  typename Orient = column_traits<3>::default_emplace_type SOAGEN_ENABLE_IF(
					  (table_traits::all_move_constructible && table_traits::all_move_assignable
					   && table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>))>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(const_iterator iter_,
							   Id&& id,
							   Name&& name	   = "",
							   Pos&& pos	   = {},
							   Orient&& orient = { 1, 0, 0, 0 }) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Id&&, Name&&, Pos&&, Orient&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable&&
									table_traits::row_constructible_from<Id&&, Name&&, Pos&&, Orient&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Id&&>(id),
						   static_cast<Name&&>(name),
						   static_cast<Pos&&>(pos),
						   static_cast<Orient&&>(orient));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Tuple SOAGEN_ENABLE_IF(
			(table_traits::row_constructible_from<Tuple&&> && table_traits::all_move_constructible
			 && table_traits::all_move_assignable && table_traits::row_constructible_from<size_type, Tuple&&>))>
		SOAGEN_CPP20_CONSTEXPR
		entities& emplace(size_type index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Tuple&&>) SOAGEN_REQUIRES(
				table_traits::row_constructible_from<Tuple&&>&& table_traits::all_move_constructible&&
					table_traits::all_move_assignable&& table_traits::row_constructible_from<size_type, Tuple&&>) //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Tuple SOAGEN_ENABLE_IF(
			(table_traits::row_constructible_from<Tuple&&> && table_traits::all_move_constructible
			 && table_traits::all_move_assignable && table_traits::row_constructible_from<iterator, Tuple&&>))>
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(iterator iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Tuple&&>) SOAGEN_REQUIRES(
				table_traits::row_constructible_from<Tuple&&>&& table_traits::all_move_constructible&&
					table_traits::all_move_assignable&& table_traits::row_constructible_from<iterator, Tuple&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @brief Constructs a new row directly in-place at an arbitrary position in the table by unpacking a tuple-like object.
		///
		/// @availability This overload is only available when all the column types are move-constructible and move-assignable.
		template <typename Tuple SOAGEN_ENABLE_IF(
			(table_traits::row_constructible_from<Tuple&&> && table_traits::all_move_constructible
			 && table_traits::all_move_assignable && table_traits::row_constructible_from<const_iterator, Tuple&&>))>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(const_iterator iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Tuple&&>)
				SOAGEN_REQUIRES(table_traits::row_constructible_from<Tuple&&>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable&&
										table_traits::row_constructible_from<const_iterator, Tuple&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		/// @}

		/// @name Columns
		/// @{

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(entities, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<entities, Column>>(table_.template column<Column>());
		}

		/// @brief Returns a pointer to the elements of a specific column.
		template <auto Column>
		SOAGEN_COLUMN(entities, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<entities, Column>>(table_.template column<Column>());
		}

#if SOAGEN_DOXYGEN

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr std::byte* data() noexcept;

		/// @brief Returns a pointer to the raw byte backing array.
		///
		/// @availability This method is only available when all the column types are trivially-copyable.
		constexpr const std::byte* const data() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: id.
		constexpr unsigned* id() noexcept;

		/// @brief Returns a pointer to the elements in column [0]: id.
		constexpr const unsigned* id() const noexcept;

		/// @brief Returns a pointer to the elements in column [1]: name.
		constexpr std::string* name() noexcept;

		/// @brief Returns a pointer to the elements in column [1]: name.
		constexpr const std::string* name() const noexcept;

		/// @brief Returns a pointer to the elements in column [2]: pos.
		constexpr vec3* pos() noexcept;

		/// @brief Returns a pointer to the elements in column [2]: pos.
		constexpr const vec3* pos() const noexcept;

		/// @brief Returns a pointer to the elements in column [3]: orient.
		constexpr quaternion* orient() noexcept;

		/// @brief Returns a pointer to the elements in column [3]: orient.
		constexpr const quaternion* orient() const noexcept;

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) noexcept(...);

		/// @brief Invokes a function once for each column data pointer.
		///
		/// @tparam Func A callable type compatible with one of the following signatures:<ul>
		/// <li> `void(auto*, std::integral_constant<size_type, N>)`
		/// <li> `void(auto*, size_type)`
		/// <li> `void(std::integral_constant<size_type, N>, auto*)`
		/// <li> `void(size_type, auto*)`
		/// <li> `void(auto*)`
		/// </ul>
		/// Overload resolution is performed in the order listed above.
		///
		/// @param func The callable to invoke.
		template <typename Func>
		constexpr void for_each_column(Func&& func) const noexcept(...);

#endif

		/// @}

#if SOAGEN_DOXYGEN

		/// @name Capacity
		/// @{

		/// @brief Returns true if the number of rows is zero.
		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept;

		/// @brief Returns the current number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept;

		/// @brief Returns the maximum possible number of rows.
		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept;

		/// @brief Returns the size of the current underlying buffer allocation in bytes.
		///
		/// @warning This value is `capacity() * (sizeof() for every column) + (alignment padding)`.
		/// It is **not** based on `size()`! If you are using the value returned by this function
		/// in conjunction with `data()` to do serialization, hashing, etc, use `shrink_to_fit()` first.
		constexpr size_type allocation_size() const noexcept;

		/// @brief Reserves storage for (at least) the given number of rows.
		entities& reserve(size_type new_cap) noexcept(...)

			/// @brief Returns the number of rows that can be held in currently allocated storage.
			constexpr size_type capacity() const noexcept;

		/// @brief Frees unused capacity.
		entities& shrink_to_fit() noexcept(...);

		/// @}

		/// @name Equality
		/// @availability These operators are only available when all the column types are equality-comparable.
		/// @{

		/// @brief Returns true if all of the elements in two tables are equal.
		friend constexpr bool operator==(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @brief Returns true if not all of the elements in two tables are equal.
		friend constexpr bool operator!=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_equality_comparable<table_type>);

		/// @}

		/// @name Comparison
		/// @availability These operators are only available when all the column types are less-than-comparable.
		/// @{

		/// @brief Returns true if the LHS table is ordered lexicographically less-than the RHS table.
		friend constexpr bool operator<(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically less-than-or-equal-to the RHS table.
		friend constexpr bool operator<=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than the RHS table.
		friend constexpr bool operator>(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @brief Returns true if the LHS table is ordered lexicographically greater-than-or-equal-to the RHS table.
		friend constexpr bool operator>=(const entities& lhs, const entities& rhs) //
			noexcept(soagen::is_nothrow_less_than_comparable<table_type>);

		/// @}

		/// @name Iterators
		/// @{

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Columns>
		constexpr soagen::iterator_type<entities, Columns...> begin() & noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Columns>
		constexpr soagen::iterator_type<entities, Columns...> end() & noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Columns>
		constexpr soagen::iterator_type<entities&&, Columns...> begin() && noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Columns>
		constexpr soagen::iterator_type<entities&&, Columns...> end() && noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Columns>
		constexpr soagen::const_iterator_type<entities, Columns...> begin() const& noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Columns>
		constexpr soagen::const_iterator_type<entities, Columns...> end() const& noexcept;

		/// @brief Returns an iterator to the first row in the table.
		template <auto... Columns>
		constexpr soagen::const_iterator_type<entities, Columns...> cbegin() const noexcept;

		/// @brief Returns an iterator to one-past-the-last row in the table.
		template <auto... Columns>
		constexpr soagen::const_iterator_type<entities, Columns...> cend() const noexcept;

		/// @}

		/// @name Rows
		/// @{

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		soagen::row_type<entities, Columns...> row(size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		row_type operator[](size_type index) & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		row_type at(size_type index) &;

		/// @brief Returns the very first row in the table.
		row_type front() & noexcept;

		/// @brief Returns the very last row in the table.
		row_type back() & noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		soagen::row_type<entities&&, Columns...> row(size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		rvalue_row_type operator[](size_type index) && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		rvalue_row_type at(size_type index) &&;

		/// @brief Returns the very first row in the table.
		rvalue_row_type front() && noexcept;

		/// @brief Returns the very last row in the table.
		rvalue_row_type back() && noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @tparam Columns Indices of the columns to include in the row. Leave the list empty for all columns.
		template <auto... Columns>
		soagen::row_type<const entities, Columns...> row(size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		const_row_type operator[](size_type index) const& noexcept;

		/// @brief Returns the row at the given index.
		///
		/// @throws std::out_of_range
		const_row_type at(size_type index) const&;

		/// @brief Returns the very first row in the table.
		const_row_type front() const& noexcept;

		/// @brief Returns the very last row in the table.
		const_row_type back() const& noexcept;

		/// @}

		/// @name Spans
		/// @{

		/// @brief Returns a span of (some part of) the table.
		span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) & noexcept;

		/// @brief Returns an rvalue-qualified span of (some part of) the table.
		rvalue_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) && noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type subspan(size_type start, size_type count = static_cast<size_type>(-1)) const& noexcept;

		/// @brief Returns a const-qualified span of (some part of) the table.
		const_span_type const_subspan(size_type start, size_type count = static_cast<size_type>(-1)) const noexcept;

		/// @}

#endif
	};

	/// @brief Swaps the contents of two instances of #soagen::examples::entities.
	///
	/// @availability	This overload is only available when #soagen::examples::entities::allocator_type
	/// is swappable or non-propagating.
	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<entities>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(entities& lhs, entities& rhs) //
		noexcept(soagen::has_nothrow_swap_member<entities>)
	{
		lhs.swap(rhs);
	}

	/// @cond

	/// @endcond
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
