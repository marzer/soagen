//# This file is a part of marzer/soagen and is subject to the the terms of the MIT license.
//# Copyright (c) Mark Gillard <mark.gillard@outlook.com.au>
//# See https://github.com/marzer/soagen/blob/master/LICENSE for the full license text.
//# SPDX-License-Identifier: MIT
#pragma once

#include "preprocessor.hpp"

{% macros::prefix %}DISABLE_WARNINGS;
#include <cstdint>
#include <cstddef>
#include <cstdlib>
#include <numeric>
#include <type_traits>
#include <new>
#include <utility>
#include <memory>
#if {% macros::prefix %}CPP >= 20 && defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806
	#include <bit>
#endif
{% macros::prefix %}ENABLE_WARNINGS;

#include "header_start.hpp"

#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
	#define {% macros::prefix %}LAUNDER(...) std::launder(__VA_ARGS__)
#elif {% macros::prefix %}CLANG >= 8 || {% macros::prefix %}GCC >= 7 || {% macros::prefix %}ICC >= 1910 \
		|| {% macros::prefix %}MSVC >= 1914 || {% macros::prefix %}HAS_BUILTIN(__builtin_launder)
	#define {% macros::prefix %}LAUNDER(...) __builtin_launder(__VA_ARGS__)
#else
	#define {% macros::prefix %}LAUNDER(...) __VA_ARGS__
#endif

//--- typedefs and type traits -----------------------------------------------------------------------------------------

namespace {% namespace %}
{
	using std::size_t;
	using std::ptrdiff_t;
	using std::intptr_t;
	using std::uintptr_t;
	using std::nullptr_t;

	template <typename T>
	using remove_cvref = std::remove_cv_t<std::remove_reference_t<T>>;

	template <typename T>
	inline constexpr bool is_cv = !std::is_same_v<std::remove_cv_t<T>, T>;

	template <typename T>
	inline constexpr bool is_cvref = !std::is_same_v<remove_cvref<T>, T>;

	template <typename T>
	inline constexpr bool is_integer = std::is_integral_v<T> && !std::is_same_v<T, bool>;

	template <typename... T>
	inline constexpr bool all_integer = (!!sizeof...(T) && ... && is_integer<T>);

	template <typename T>
	inline constexpr bool is_unsigned = is_integer<T> && std::is_unsigned_v<T>;

	template <typename T, typename... U>
	inline constexpr bool any_same = (false || ... || std::is_same_v<T, U>);

	template <auto Value>
	using index_tag = std::integral_constant<size_t, static_cast<size_t>(Value)>;

	//% meta::type_at_index

	//% meta::is_trivially_manifestable

	//% meta::is_detected

	namespace {% namespaces::detail %}
	{
		template <typename T>
		using has_swap_member_ = decltype(std::declval<T&>().swap(std::declval<T&>()));

		template <typename T>
		using has_resize_member_ = decltype(std::declval<T&>().resize(size_t{}));
	}

	template <typename T>
	inline constexpr bool has_swap_member = is_detected<{% namespaces::detail %}::has_swap_member_, T>;

	template <typename T>
	inline constexpr bool has_resize_member = is_detected<{% namespaces::detail %}::has_resize_member_, T>;

	namespace {% namespaces::detail %}
	{
		template <typename T, bool = has_swap_member<T>>
		struct has_nothrow_swap_member_ : std::bool_constant<noexcept(std::declval<T&>().swap(std::declval<T&>()))> {};
		template <typename T>
		struct has_nothrow_swap_member_<T, false> : std::false_type {};

		template <typename T, bool = has_resize_member<T>>
		struct has_nothrow_resize_member_ : std::bool_constant<noexcept(std::declval<T&>().resize(size_t{}))> {};
		template <typename T>
		struct has_nothrow_resize_member_<T, false> : std::false_type {};
	}

	template <typename T>
	inline constexpr bool has_nothrow_swap_member = {% namespaces::detail %}::has_nothrow_swap_member_<T>::value;

	template <typename T>
	inline constexpr bool has_nothrow_resize_member = {% namespaces::detail %}::has_nothrow_resize_member_<T>::value;

	template <typename T>
	inline constexpr bool is_soa = false;
}

//--- functions --------------------------------------------------------------------------------------------------------

namespace {% namespace %}
{
	//% is_constant_evaluated

	//% min

	//% max

	//% lcm

	//% has_single_bit


#if {% macros::prefix %}CPP >= 20 && defined(__cpp_lib_bit_cast) && __cpp_lib_bit_cast >= 201806

	#define {% macros::prefix %}HAS_INTRINSIC_BIT_CAST 1

	using std::bit_cast;

#else

	//% bit_cast

#endif

#if {% macros::prefix %}CPP >= 20 && defined(__cpp_lib_assume_aligned) && __cpp_lib_assume_aligned >= 201811

	using std::assume_aligned;

#else

	//% assume_aligned

#endif

}


#include "header_end.hpp"
