//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.7.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 7
	#error soagen version mismatch - expected v0.7.X
#endif

SOAGEN_DISABLE_WARNINGS;
#include <string>
#include <tuple>
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

// clang-format off

namespace tests
{
	class employees;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_date_of_birth
		#define SOAGEN_NAME_date_of_birth
		SOAGEN_MAKE_NAME(date_of_birth);
	#endif

	#ifndef SOAGEN_NAME_id
		#define SOAGEN_NAME_id
		SOAGEN_MAKE_NAME(id);
	#endif

	#ifndef SOAGEN_NAME_name
		#define SOAGEN_NAME_name
		SOAGEN_MAKE_NAME(name);
	#endif

	#ifndef SOAGEN_NAME_salary
		#define SOAGEN_NAME_salary
		SOAGEN_MAKE_NAME(salary);
	#endif

	#ifndef SOAGEN_NAME_tag
		#define SOAGEN_NAME_tag
		SOAGEN_MAKE_NAME(tag);
	#endif
}

namespace soagen_struct_impl_tests_employees
{
	SOAGEN_DISABLE_WARNINGS;
	using namespace tests;
	SOAGEN_ENABLE_WARNINGS;

	using soagen_table_traits_type = soagen::table_traits<
				 /* 		 name */ soagen::column_traits<const std::string>,
				 /* 		   id */ soagen::column_traits<unsigned long long, soagen::max(std::size_t{ 32u }, alignof(unsigned long long))>,
				 /* date_of_birth */ soagen::column_traits<std::tuple<int, int, int>>,
				 /* 	   salary */ soagen::column_traits<int>,
				 /* 		  tag */ soagen::column_traits<int*>>;

	using soagen_allocator_type = soagen::allocator;
}

namespace soagen::detail
{
	SOAGEN_MAKE_NAMED_COLUMN(tests::employees, 0, name);
	SOAGEN_MAKE_NAMED_COLUMN(tests::employees, 1, id);
	SOAGEN_MAKE_NAMED_COLUMN(tests::employees, 2, date_of_birth);
	SOAGEN_MAKE_NAMED_COLUMN(tests::employees, 3, salary);
	SOAGEN_MAKE_NAMED_COLUMN(tests::employees, 4, tag);

	template <>
	struct is_soa_<tests::employees> : std::true_type
	{};

	template <>
	struct table_traits_type_<tests::employees>
	{
		using type = soagen_struct_impl_tests_employees::soagen_table_traits_type;
	};

	template <>
	struct allocator_type_<tests::employees>
	{
		using type = soagen_struct_impl_tests_employees::soagen_allocator_type;
	};

	template <>
	struct table_type_<tests::employees>
	{
		using type = table<table_traits_type<tests::employees>, allocator_type<tests::employees>>;
	};
}

// clang-format on

//----------------------------------------------------------------------------------------------------------------------
// employees
//----------------------------------------------------------------------------------------------------------------------

namespace tests
{
	class SOAGEN_EMPTY_BASES employees //
		: public soagen::mixins::size_and_capacity<employees>,
		  public soagen::mixins::resizable<employees>,
		  public soagen::mixins::equality_comparable<employees>,
		  public soagen::mixins::less_than_comparable<employees>,
		  public soagen::mixins::data_ptr<employees>,
		  public soagen::mixins::columns<employees>,
		  public soagen::mixins::rows<employees>,
		  public soagen::mixins::iterators<employees>,
		  public soagen::mixins::spans<employees>,
		  public soagen::mixins::swappable<employees>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<employees>;

		using table_type = soagen::table_type<employees>;

		using table_traits = soagen::table_traits_type<employees>;

		static constexpr size_type column_count = table_traits::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<employees>;

		using rvalue_iterator = soagen::iterator_type<employees&&>;

		using const_iterator = soagen::const_iterator_type<employees>;

		using span_type = soagen::span_type<employees>;

		using rvalue_span_type = soagen::span_type<employees&&>;

		using const_span_type = soagen::const_span_type<employees>;

		using row_type = soagen::row_type<employees>;

		using rvalue_row_type = soagen::row_type<employees&&>;

		using const_row_type = soagen::const_row_type<employees>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			name		  = 0,
			id			  = 1,
			date_of_birth = 2,
			salary		  = 3,
			tag			  = 4,
		};

		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<employees, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		employees() = default;

		SOAGEN_NODISCARD_CTOR
		employees(employees&&) = default;

		employees& operator=(employees&&) = default;

		SOAGEN_NODISCARD_CTOR
		employees(const employees&) = default;

		employees& operator=(const employees&) = default;

		~employees() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit employees(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit employees(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&() noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator table_type&&() noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		explicit constexpr operator const table_type&() const noexcept
		{
			return table_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR									   //
		std::enable_if_t<sfinae, employees&> erase(size_type pos)  //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(pos);
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR																 //
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)				 //
		{
			return table_.unordered_erase(pos);
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos)	   //
			noexcept(soagen::has_nothrow_erase_member<table_type>) //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)			   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type>)		   //
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = soagen::has_unordered_erase_member<table_type>)
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type>)						   //
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <auto A, auto B>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		employees& swap_columns() //
			noexcept(noexcept(std::declval<table_type&>()
								  .template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>()))
		{
			table_.template swap_columns<static_cast<size_type>(A), static_cast<size_type>(B)>();
			return *this;
		}

		// ------ push_back() --------------------------------------------------------------------------

		SOAGEN_CPP20_CONSTEXPR
		employees& push_back(column_traits<0>::param_type name,
							 column_traits<1>::param_type id,
							 column_traits<2>::param_type date_of_birth,
							 column_traits<3>::param_type salary,
							 column_traits<4>::param_type tag = nullptr) //
			noexcept(table_traits::push_back_is_nothrow<table_type>)	 //
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(name),
								static_cast<column_traits<1>::param_forward_type>(id),
								static_cast<column_traits<2>::param_forward_type>(date_of_birth),
								static_cast<column_traits<3>::param_forward_type>(salary),
								static_cast<column_traits<4>::param_forward_type>(tag));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = table_traits::rvalues_are_distinct)
		SOAGEN_CPP20_CONSTEXPR
		employees& push_back(column_traits<0>::rvalue_type name,
							 column_traits<1>::rvalue_type id,
							 column_traits<2>::rvalue_type date_of_birth,
							 column_traits<3>::rvalue_type salary,
							 column_traits<4>::rvalue_type tag = nullptr)	//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type>) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(name),
								static_cast<column_traits<1>::rvalue_forward_type>(id),
								static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
								static_cast<column_traits<3>::rvalue_forward_type>(salary),
								static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return *this;
		}

		// ------ emplace_back() -----------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			(table_traits::row_constructible_from<Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>), //
			typename Name,
			typename Id,
			typename DateOfBirth,
			typename Salary,
			typename Tag = column_traits<4>::default_emplace_type) //
		SOAGEN_CPP20_CONSTEXPR
		employees& emplace_back(Name&& name,
								Id&& id,
								DateOfBirth&& date_of_birth,
								Salary&& salary,
								Tag&& tag = nullptr)																  //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>) //
		{
			table_.emplace_back(static_cast<Name&&>(name),
								static_cast<Id&&>(id),
								static_cast<DateOfBirth&&>(date_of_birth),
								static_cast<Salary&&>(salary),
								static_cast<Tag&&>(tag));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(table_traits::row_constructible_from<Tuple>, typename Tuple)
		SOAGEN_CPP20_CONSTEXPR
		employees& emplace_back(Tuple&& tuple_)									 //
			noexcept(table_traits::emplace_back_is_nothrow<table_type, Tuple&&>) //
		{
			table_.emplace_back(static_cast<Tuple&&>(tuple_));
			return *this;
		}

	  private:
		static constexpr bool can_insert_ =
			table_traits::all_move_or_copy_constructible && table_traits::all_move_or_copy_assignable;

		static constexpr bool can_insert_rvalues_ = can_insert_ && table_traits::rvalues_are_distinct;

	  public:
		// ------ insert(size_type) --------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, employees&> insert(size_type index_,
													column_traits<0>::param_type name,
													column_traits<1>::param_type id,
													column_traits<2>::param_type date_of_birth,
													column_traits<3>::param_type salary,
													column_traits<4>::param_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)								//
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return *this;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		employees& insert(std::enable_if_t<sfinae, size_type> index_,
						  column_traits<0>::rvalue_type name,
						  column_traits<1>::rvalue_type id,
						  column_traits<2>::rvalue_type date_of_birth,
						  column_traits<3>::rvalue_type salary,
						  column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)	   //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return *this;
		}

		// ------ insert(iterator) ---------------------------------------------------------------------

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type name,
												  column_traits<1>::param_type id,
												  column_traits<2>::param_type date_of_birth,
												  column_traits<3>::param_type salary,
												  column_traits<4>::param_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)							  //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type name,
														column_traits<1>::param_type id,
														column_traits<2>::param_type date_of_birth,
														column_traits<3>::param_type salary,
														column_traits<4>::param_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)									//
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type name,
						column_traits<1>::rvalue_type id,
						column_traits<2>::rvalue_type date_of_birth,
						column_traits<3>::rvalue_type salary,
						column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)	 //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return iter_;
		}

		SOAGEN_HIDDEN_CONSTRAINT(sfinae, bool sfinae = can_insert_rvalues_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type name,
							  column_traits<1>::rvalue_type id,
							  column_traits<2>::rvalue_type date_of_birth,
							  column_traits<3>::rvalue_type salary,
							  column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::insert_is_nothrow<table_type>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return iter_;
		}

		// ------ emplace(size_type) -------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Name,
			typename Id,
			typename DateOfBirth,
			typename Salary,
			typename Tag = column_traits<4>::default_emplace_type,
			bool sfinae	 = table_traits::row_constructible_from<Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>
					   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, employees&> emplace(size_type index_,
													 Name&& name,
													 Id&& id,
													 DateOfBirth&& date_of_birth,
													 Salary&& salary,
													 Tag&& tag = nullptr)										 //
			noexcept(table_traits::emplace_is_nothrow<table_type, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>) //
		{
			table_.emplace(index_,
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return *this;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		employees& emplace(std::enable_if_t<sfinae, size_type> index_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)			   //
		{
			table_.emplace(index_, static_cast<Tuple&&>(tuple_));
			return *this;
		}

		// ------ emplace(iterator) --------------------------------------------------------------------

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Name,
			typename Id,
			typename DateOfBirth,
			typename Salary,
			typename Tag = column_traits<4>::default_emplace_type,
			bool sfinae	 = table_traits::row_constructible_from<Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>
					   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Name&& name,
												   Id&& id,
												   DateOfBirth&& date_of_birth,
												   Salary&& salary,
												   Tag&& tag = nullptr)											 //
			noexcept(table_traits::emplace_is_nothrow<table_type, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		iterator emplace(std::enable_if_t<sfinae, iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)		   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(
			sfinae,
			typename Name,
			typename Id,
			typename DateOfBirth,
			typename Salary,
			typename Tag = column_traits<4>::default_emplace_type,
			bool sfinae	 = table_traits::row_constructible_from<Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>
					   && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Name&& name,
														 Id&& id,
														 DateOfBirth&& date_of_birth,
														 Salary&& salary,
														 Tag&& tag = nullptr)									 //
			noexcept(table_traits::emplace_is_nothrow<table_type, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return iter_;
		}

		SOAGEN_CONSTRAINED_TEMPLATE(sfinae,
									typename Tuple,
									bool sfinae = table_traits::row_constructible_from<Tuple&&> && can_insert_) //
		SOAGEN_CPP20_CONSTEXPR
		const_iterator emplace(std::enable_if_t<sfinae, const_iterator> iter_, Tuple&& tuple_) //
			noexcept(table_traits::emplace_is_nothrow<table_type, Tuple&&>)					   //
		{
			table_.emplace(static_cast<size_type>(iter_), static_cast<Tuple&&>(tuple_));
			return iter_;
		}

		template <auto Column>
		SOAGEN_COLUMN(employees, Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<employees, Column>>(
				table_.template column<Column>());
		}

		template <auto Column>
		SOAGEN_COLUMN(employees, Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<soagen::actual_alignment<employees, Column>>(
				table_.template column<Column>());
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<employees>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(employees& lhs, employees& rhs) //
		noexcept(soagen::has_nothrow_swap_member<employees>)
	{
		lhs.swap(rhs);
	}
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
