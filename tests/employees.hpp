//----------------------------------------------------------------------------------------------------------------------
// This file was generated by soagen v0.2.0 - do not modify it directly
// https://marzer.github.io/soagen
//----------------------------------------------------------------------------------------------------------------------
#pragma once

#include <soagen.hpp>
#if SOAGEN_VERSION_MAJOR != 0 || SOAGEN_VERSION_MINOR < 2
	#error soagen version mismatch - expected v0.2.X
#endif

SOAGEN_DISABLE_WARNINGS;
#include <string>
#include <tuple>
#if SOAGEN_HAS_EXCEPTIONS
	#include <stdexcept>
#endif
SOAGEN_ENABLE_WARNINGS;

SOAGEN_PUSH_WARNINGS;
SOAGEN_DISABLE_SPAM_WARNINGS;
#if SOAGEN_CLANG >= 16
	#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(on)
#endif
#if SOAGEN_MSVC_LIKE
	#pragma push_macro("min")
	#pragma push_macro("max")
	#undef min
	#undef max
#endif

//----------------------------------------------------------------------------------------------------------------------
// forward declarations + soagen internal boilerplate
//----------------------------------------------------------------------------------------------------------------------

// clang-format off

namespace tests
{
	class employees;
}

namespace soagen
{
	template <>
	inline constexpr bool is_soa<tests::employees> = true;
}

namespace soagen::detail
{
	#ifndef SOAGEN_NAME_date_of_birth
		#define SOAGEN_NAME_date_of_birth
		SOAGEN_MAKE_NAME(date_of_birth);
	#endif

	#ifndef SOAGEN_NAME_id
		#define SOAGEN_NAME_id
		SOAGEN_MAKE_NAME(id);
	#endif

	#ifndef SOAGEN_NAME_name
		#define SOAGEN_NAME_name
		SOAGEN_MAKE_NAME(name);
	#endif

	#ifndef SOAGEN_NAME_salary
		#define SOAGEN_NAME_salary
		SOAGEN_MAKE_NAME(salary);
	#endif

	#ifndef SOAGEN_NAME_tag
		#define SOAGEN_NAME_tag
		SOAGEN_MAKE_NAME(tag);
	#endif

	template <>
	struct table_traits_type_<tests::employees>
	{
		using type = table_traits<
		/*			name */ column_traits<const std::string>,
		/*			  id */ column_traits<unsigned long long, soagen::max(size_t{ 32 }, alignof(unsigned long long))>,
		/* date_of_birth */ column_traits<std::tuple<int, int, int>>,
		/*		  salary */ column_traits<int>,
		/*			 tag */ column_traits<int*>>;
	};

	template <>
	struct allocator_type_<tests::employees>
	{
		using type = soagen::allocator;
	};

	SOAGEN_MAKE_COLUMN(tests::employees, 0, name);
	SOAGEN_MAKE_COLUMN(tests::employees, 1, id);
	SOAGEN_MAKE_COLUMN(tests::employees, 2, date_of_birth);
	SOAGEN_MAKE_COLUMN(tests::employees, 3, salary);
	SOAGEN_MAKE_COLUMN(tests::employees, 4, tag);

	template <>
	struct table_type_<tests::employees>
	{
		using type = table<table_traits_type<tests::employees>, soagen::allocator>;
	};
}

// clang-format on

//----------------------------------------------------------------------------------------------------------------------
// employees
//----------------------------------------------------------------------------------------------------------------------

namespace tests
{
	class SOAGEN_EMPTY_BASES employees //
		: public soagen::mixins::resizable<employees>,
		  public soagen::mixins::equality_comparable<employees>,
		  public soagen::mixins::less_than_comparable<employees>,
		  public soagen::mixins::data_ptr<employees>,
		  public soagen::mixins::const_data_ptr<employees>,
		  public soagen::mixins::swappable<employees>
	{
	  public:
		using size_type = std::size_t;

		using difference_type = std::ptrdiff_t;

		using allocator_type = soagen::allocator_type<employees>;

		using table_type = soagen::table_type<employees>;

		using table_traits = soagen::table_traits_type<employees>;

		static constexpr size_type column_count = soagen::table_traits_type<employees>::column_count;

		template <auto Column>
		using column_traits = typename table_traits::template column<static_cast<size_type>(Column)>;

		template <auto Column>
		using column_type = typename column_traits<static_cast<size_type>(Column)>::value_type;

		using iterator = soagen::iterator_type<employees&>;

		using const_iterator = soagen::iterator_type<const employees&>;

		using rvalue_iterator = soagen::iterator_type<employees&&>;

		using row_type = soagen::row_type<employees&>;

		using const_row_type = soagen::row_type<const employees&>;

		using rvalue_row_type = soagen::row_type<employees&&>;

		static constexpr size_type aligned_stride = table_traits::aligned_stride;

		enum class columns : size_type
		{
			name		  = 0,
			id			  = 1,
			date_of_birth = 2,
			salary		  = 3,
			tag			  = 4,
		};

		template <auto Column>
		static constexpr auto& column_name =
			soagen::detail::column_name<employees, static_cast<size_type>(Column)>::value;

	  private:
		table_type table_;

	  public:
		SOAGEN_NODISCARD_CTOR
		employees() = default;

		SOAGEN_NODISCARD_CTOR
		employees(employees&&) = default;

		employees& operator=(employees&&) = default;

		SOAGEN_NODISCARD_CTOR
		employees(const employees&) = default;

		employees& operator=(const employees&) = default;

		~employees() = default;

		SOAGEN_NODISCARD_CTOR
		constexpr explicit employees(const allocator_type& alloc) noexcept //
			: table_{ alloc }
		{}

		SOAGEN_NODISCARD_CTOR
		constexpr explicit employees(allocator_type&& alloc) noexcept //
			: table_{ static_cast<allocator_type&&>(alloc) }
		{}

		SOAGEN_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		allocator_type get_allocator() const noexcept
		{
			return table_.get_allocator();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type& table() & noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr table_type&& table() && noexcept
		{
			return static_cast<table_type&&>(table_);
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr const table_type& table() const& noexcept
		{
			return table_;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr bool empty() const noexcept
		{
			return table_.empty();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type size() const noexcept
		{
			return table_.size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type max_size() const noexcept
		{
			return table_.max_size();
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type allocation_size() const noexcept
		{
			return table_.allocation_size();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		employees& reserve(size_type new_cap) //
			noexcept(noexcept(std::declval<table_type&>().reserve(size_type{})))
		{
			table_.reserve(new_cap);
			return *this;
		}

		SOAGEN_PURE_INLINE_GETTER
		constexpr size_type capacity() const noexcept
		{
			return table_.capacity();
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		employees& shrink_to_fit() //
			noexcept(noexcept(std::declval<table_type&>().shrink_to_fit()))
		{
			table_.shrink_to_fit();
			return *this;
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		employees& clear() noexcept
		{
			table_.clear();
			return *this;
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, employees&> erase(size_type pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(pos);
			return *this;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<size_type>> unordered_erase(size_type pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			return table_.unordered_erase(pos);
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> erase(iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<iterator>> unordered_erase(iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		template <bool sfinae = soagen::has_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_erase_member<table_type, size_type>)
		{
			table_.erase(static_cast<size_type>(pos));
			return pos;
		}

		template <bool sfinae = soagen::has_unordered_erase_member<table_type, size_type>>
		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, soagen::optional<const_iterator>> unordered_erase(const_iterator pos) //
			noexcept(soagen::has_nothrow_unordered_erase_member<table_type, size_type>)
		{
			if (auto moved_pos = table_.unordered_erase(static_cast<size_type>(pos)); moved_pos)
				return const_iterator{ *this, static_cast<difference_type>(*moved_pos) };
			return {};
		}

		SOAGEN_ALWAYS_INLINE
		SOAGEN_CPP20_CONSTEXPR
		employees& pop_back(size_type num = 1) //
			noexcept(noexcept(std::declval<table_type&>().pop_back(size_type{})))
		{
			table_.pop_back(num);
			return *this;
		}

		SOAGEN_CPP20_CONSTEXPR
		employees& push_back(column_traits<0>::param_type name,
							 column_traits<1>::param_type id,
							 column_traits<2>::param_type date_of_birth,
							 column_traits<3>::param_type salary,
							 column_traits<4>::param_type tag = nullptr) //
			noexcept(table_traits::push_back_is_nothrow<table_type&>)
		{
			table_.emplace_back(static_cast<column_traits<0>::param_forward_type>(name),
								static_cast<column_traits<1>::param_forward_type>(id),
								static_cast<column_traits<2>::param_forward_type>(date_of_birth),
								static_cast<column_traits<3>::param_forward_type>(salary),
								static_cast<column_traits<4>::param_forward_type>(tag));
			return *this;
		}

		template <bool sfinae = table_traits::rvalue_type_list_is_distinct>
		SOAGEN_CPP20_CONSTEXPR
		employees& push_back(std::enable_if_t<sfinae, column_traits<0>::rvalue_type> name,
							 column_traits<1>::rvalue_type id,
							 column_traits<2>::rvalue_type date_of_birth,
							 column_traits<3>::rvalue_type salary,
							 column_traits<4>::rvalue_type tag = nullptr)	//
			noexcept(table_traits::rvalue_push_back_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct) //
		{
			table_.emplace_back(static_cast<column_traits<0>::rvalue_forward_type>(name),
								static_cast<column_traits<1>::rvalue_forward_type>(id),
								static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
								static_cast<column_traits<3>::rvalue_forward_type>(salary),
								static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return *this;
		}

		template <typename Table,
				  auto... Columns,
				  std::enable_if_t<soagen::is_soa<soagen::remove_cvref<Table>>, int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		employees& push_back(const soagen::row<Table, Columns...>& row_)	 //
			noexcept(table_traits::row_push_back_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>) //
		{
			table_.emplace_back(row_);
			return *this;
		}

		template <typename Name,
				  typename Id,
				  typename DateOfBirth,
				  typename Salary,
				  typename Tag = column_traits<4>::default_emplace_type>
		SOAGEN_CPP20_CONSTEXPR
		employees& emplace_back(Name&& name,
								Id&& id,
								DateOfBirth&& date_of_birth,
								Salary&& salary,
								Tag&& tag = nullptr) //
			noexcept(table_traits::emplace_back_is_nothrow<table_type&, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>)
		{
			table_.emplace_back(static_cast<Name&&>(name),
								static_cast<Id&&>(id),
								static_cast<DateOfBirth&&>(date_of_birth),
								static_cast<Salary&&>(salary),
								static_cast<Tag&&>(tag));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, employees&> insert(size_type index_,
													column_traits<0>::param_type name,
													column_traits<1>::param_type id,
													column_traits<2>::param_type date_of_birth,
													column_traits<3>::param_type salary,
													column_traits<4>::param_type tag = nullptr)			  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return *this;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> insert(iterator iter_,
												  column_traits<0>::param_type name,
												  column_traits<1>::param_type id,
												  column_traits<2>::param_type date_of_birth,
												  column_traits<3>::param_type salary,
												  column_traits<4>::param_type tag = nullptr)			  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return iter_;
		}

		template <bool sfinae = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> insert(const_iterator iter_,
														column_traits<0>::param_type name,
														column_traits<1>::param_type id,
														column_traits<2>::param_type date_of_birth,
														column_traits<3>::param_type salary,
														column_traits<4>::param_type tag = nullptr)		  //
			noexcept(table_traits::insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::param_forward_type>(name),
						   static_cast<column_traits<1>::param_forward_type>(id),
						   static_cast<column_traits<2>::param_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::param_forward_type>(salary),
						   static_cast<column_traits<4>::param_forward_type>(tag));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		employees& insert(std::enable_if_t<sfinae, size_type> index_,
						  column_traits<0>::rvalue_type name,
						  column_traits<1>::rvalue_type id,
						  column_traits<2>::rvalue_type date_of_birth,
						  column_traits<3>::rvalue_type salary,
						  column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return *this;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(std::enable_if_t<sfinae, iterator> iter_,
						column_traits<0>::rvalue_type name,
						column_traits<1>::rvalue_type id,
						column_traits<2>::rvalue_type date_of_birth,
						column_traits<3>::rvalue_type salary,
						column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return iter_;
		}

		template <bool sfinae = (table_traits::rvalue_type_list_is_distinct && table_traits::all_move_constructible
								 && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(std::enable_if_t<sfinae, const_iterator> iter_,
							  column_traits<0>::rvalue_type name,
							  column_traits<1>::rvalue_type id,
							  column_traits<2>::rvalue_type date_of_birth,
							  column_traits<3>::rvalue_type salary,
							  column_traits<4>::rvalue_type tag = nullptr) //
			noexcept(table_traits::rvalue_insert_is_nothrow<table_type&>)
				SOAGEN_REQUIRES(table_traits::rvalue_type_list_is_distinct&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<column_traits<0>::rvalue_forward_type>(name),
						   static_cast<column_traits<1>::rvalue_forward_type>(id),
						   static_cast<column_traits<2>::rvalue_forward_type>(date_of_birth),
						   static_cast<column_traits<3>::rvalue_forward_type>(salary),
						   static_cast<column_traits<4>::rvalue_forward_type>(tag));
			return iter_;
		}

		template <typename Table,
				  auto... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		employees& insert(size_type index_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(index_, row_);
			return *this;
		}

		template <typename Table,
				  auto... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		iterator insert(iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Table,
				  auto... Columns,
				  std::enable_if_t<(soagen::is_soa<soagen::remove_cvref<Table>> && table_traits::all_move_constructible
									&& table_traits::all_move_assignable),
								   int> = 0>
		SOAGEN_CPP20_CONSTEXPR
		const_iterator insert(const_iterator iter_, const soagen::row<Table, Columns...>& row_) //
			noexcept(table_traits::row_insert_is_nothrow<table_type&, const soagen::row<Table, Columns...>&>)
				SOAGEN_REQUIRES(soagen::is_soa<soagen::remove_cvref<Table>>&& table_traits::all_move_constructible&&
									table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_), row_);
			return iter_;
		}

		template <typename Name,
				  typename Id,
				  typename DateOfBirth,
				  typename Salary,
				  typename Tag = column_traits<4>::default_emplace_type,
				  bool sfinae  = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, employees&> emplace(size_type index_,
													 Name&& name,
													 Id&& id,
													 DateOfBirth&& date_of_birth,
													 Salary&& salary,
													 Tag&& tag = nullptr)								  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(index_,
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return *this;
		}

		template <typename Name,
				  typename Id,
				  typename DateOfBirth,
				  typename Salary,
				  typename Tag = column_traits<4>::default_emplace_type,
				  bool sfinae  = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, iterator> emplace(iterator iter_,
												   Name&& name,
												   Id&& id,
												   DateOfBirth&& date_of_birth,
												   Salary&& salary,
												   Tag&& tag = nullptr)									  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return iter_;
		}

		template <typename Name,
				  typename Id,
				  typename DateOfBirth,
				  typename Salary,
				  typename Tag = column_traits<4>::default_emplace_type,
				  bool sfinae  = (table_traits::all_move_constructible && table_traits::all_move_assignable)>
		SOAGEN_CPP20_CONSTEXPR
		std::enable_if_t<sfinae, const_iterator> emplace(const_iterator iter_,
														 Name&& name,
														 Id&& id,
														 DateOfBirth&& date_of_birth,
														 Salary&& salary,
														 Tag&& tag = nullptr)							  //
			noexcept(table_traits::emplace_is_nothrow<table_type&, Name&&, Id&&, DateOfBirth&&, Salary&&, Tag&&>)
				SOAGEN_REQUIRES(table_traits::all_move_constructible&& table_traits::all_move_assignable) //
		{
			table_.emplace(static_cast<size_type>(iter_),
						   static_cast<Name&&>(name),
						   static_cast<Id&&>(id),
						   static_cast<DateOfBirth&&>(date_of_birth),
						   static_cast<Salary&&>(salary),
						   static_cast<Tag&&>(tag));
			return iter_;
		}

		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr column_type<Column>* column() noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		template <auto Column>
		SOAGEN_ALIGNED_COLUMN(Column)
		constexpr std::add_const_t<column_type<Column>>* column() const noexcept
		{
			static_assert(static_cast<size_type>(Column) < table_traits::column_count, "column index out of range");

			return soagen::assume_aligned<
				soagen::detail::actual_column_alignment<table_traits, allocator_type, static_cast<size_type>(Column)>>(
				table_.template column<static_cast<size_type>(Column)>());
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr const std::string* name() noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(0)
		constexpr std::add_const_t<const std::string>* name() const noexcept
		{
			return column<0>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr unsigned long long* id() noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(1)
		constexpr std::add_const_t<unsigned long long>* id() const noexcept
		{
			return column<1>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr std::tuple<int, int, int>* date_of_birth() noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(2)
		constexpr std::add_const_t<std::tuple<int, int, int>>* date_of_birth() const noexcept
		{
			return column<2>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr int* salary() noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(3)
		constexpr const int* salary() const noexcept
		{
			return column<3>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr int** tag() noexcept
		{
			return column<4>();
		}

		SOAGEN_ALIGNED_COLUMN(4)
		constexpr std::add_const_t<int*>* tag() const noexcept
		{
			return column<4>();
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
		}

		template <typename Func>
		constexpr void for_each_column(Func&& func) const //
			noexcept(table_traits::for_each_column_ptr_nothrow_invocable<Func&&, true>)
		{
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<0>(), size_type{ 0 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<1>(), size_type{ 1 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<2>(), size_type{ 2 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<3>(), size_type{ 3 });
			soagen::invoke_with_optarg(static_cast<Func&&>(func), this->template column<4>(), size_type{ 4 });
		}

		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<employees&, Columns...> row(size_type index) & noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type operator[](size_type index) & noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type at(size_type index) &
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type front() & noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		row_type back() & noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<employees&&, Columns...> row(size_type index) && noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { std::move(this->template column<static_cast<size_type>(Columns)>()[index]) }... };
			}
			else
			{
				return std::move(*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type operator[](size_type index) && noexcept
		{
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type at(size_type index) &&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return std::move(*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type front() && noexcept
		{
			return std::move(*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		rvalue_row_type back() && noexcept
		{
			return std::move(*this).row(size() - 1u);
		}

		template <auto... Columns>
		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		soagen::row_type<const employees&, Columns...> row(size_type index) const& noexcept
		{
			if constexpr (sizeof...(Columns))
			{
				return { { this->template column<static_cast<size_type>(Columns)>()[index] }... };
			}
			else
			{
				return (*this).template row<0, 1, 2, 3, 4>(index);
			}
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type operator[](size_type index) const& noexcept
		{
			return (*this).row(index);
		}

		SOAGEN_PURE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type at(size_type index) const&
		{
#if SOAGEN_HAS_EXCEPTIONS
			if (index >= size())
				throw std::out_of_range{ "bad element access" };
#endif
			return (*this).row(index);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type front() const& noexcept
		{
			return (*this).row(0u);
		}

		SOAGEN_PURE_INLINE_GETTER
		SOAGEN_CPP20_CONSTEXPR
		const_row_type back() const& noexcept
		{
			return (*this).row(size() - 1u);
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<employees&, Columns...> begin() & noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<employees&, Columns...> end() & noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<employees&&, Columns...> begin() && noexcept
		{
			return { std::move(*this), 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<employees&&, Columns...> end() && noexcept
		{
			return { std::move(*this), static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const employees&, Columns...> begin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const employees&, Columns...> end() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const employees&, Columns...> cbegin() const& noexcept
		{
			return { *this, 0 };
		}

		template <size_type... Columns>
		SOAGEN_PURE_INLINE_GETTER
		constexpr soagen::iterator_type<const employees&, Columns...> cend() const& noexcept
		{
			return { *this, static_cast<difference_type>(size()) };
		}
	};

	SOAGEN_HIDDEN_CONSTRAINT(sfinae, auto sfinae = soagen::has_swap_member<employees>)
	SOAGEN_ALWAYS_INLINE
	constexpr void swap(employees& lhs, employees& rhs) //
		noexcept(soagen::has_nothrow_swap_member<employees>)
	{
		lhs.swap(rhs);
	}
}

#if SOAGEN_MSVC_LIKE
	#pragma pop_macro("min")
	#pragma pop_macro("max")
#endif
#if SOAGEN_MSVC
	#pragma inline_recursion(off)
#endif
SOAGEN_POP_WARNINGS;
